<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Vue.js</title>

<script src="site_libs/header-attrs-2.24/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #a0a0a0;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
div.sourceCode
  { color: #1f1c1b; background-color: #ffffff; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { color: #1f1c1b; } /* Normal */
code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
code span.an { color: #ca60ca; } /* Annotation */
code span.at { color: #0057ae; } /* Attribute */
code span.bn { color: #b08000; } /* BaseN */
code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #924c9d; } /* Char */
code span.cn { color: #aa5500; } /* Constant */
code span.co { color: #898887; } /* Comment */
code span.cv { color: #0095ff; } /* CommentVar */
code span.do { color: #607880; } /* Documentation */
code span.dt { color: #0057ae; } /* DataType */
code span.dv { color: #b08000; } /* DecVal */
code span.er { color: #bf0303; text-decoration: underline; } /* Error */
code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #644a9b; } /* Function */
code span.im { color: #ff5500; } /* Import */
code span.in { color: #b08000; } /* Information */
code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code span.op { color: #1f1c1b; } /* Operator */
code span.ot { color: #006e28; } /* Other */
code span.pp { color: #006e28; } /* Preprocessor */
code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #ff5500; } /* SpecialString */
code span.st { color: #bf0303; } /* String */
code span.va { color: #0057ae; } /* Variable */
code span.vs { color: #bf0303; } /* VerbatimString */
code span.wa { color: #bf0303; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>







<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Programozás jegyzeteim</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Vanilla JS
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="vanilla/js-variables.html">JavaScript alapok</a>
    </li>
    <li>
      <a href="vanilla/js-program-flow.html">Program Flow Control</a>
    </li>
    <li>
      <a href="vanilla/js-functions.html">Függvények</a>
    </li>
    <li>
      <a href="vanilla/js-data-structures.html">Adatstruktúrák</a>
    </li>
    <li>
      <a href="vanilla/js-array-methods.html">Haladó Array műveletek</a>
    </li>
    <li>
      <a href="vanilla/js-dom-manipulation.html">DOM manipuláció</a>
    </li>
    <li>
      <a href="vanilla/js-strings.html">Stringek</a>
    </li>
    <li>
      <a href="vanilla/js-numbers-dates.html">Számok és dátumok</a>
    </li>
    <li>
      <a href="vanilla/js-regex.html">Reguláris kifejezések</a>
    </li>
    <li>
      <a href="vanilla/js-async.html">Asynchronous JavaScript</a>
    </li>
    <li>
      <a href="vanilla/js-oop.html">OOP</a>
    </li>
    <li>
      <a href="vanilla/js-dev-practice.html">JavaScript Development a gyakorlatban</a>
    </li>
    <li>
      <a href="vanilla/js-api.html">Hasznos API-k</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Typescript
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="ts-basics.html">TypeScript basics</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Front-End JS Libraries&amp;Frameworks
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="front-end/jquery-basics.html">jQuery</a>
    </li>
    <li>
      <a href="front-end/react-basics.html">React</a>
    </li>
    <li>
      <a href="front-end/redux-basics.html">Redux</a>
    </li>
    <li>
      <a href="front-end/next.html">Next</a>
    </li>
    <li>
      <a href="front-end/vue-basics.html">Vue.js</a>
    </li>
    <li>
      <a href="front-end/angular.html">Angular</a>
    </li>
    <li>
      <a href="front-end/svelte.html">Svelte</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Back-End JS
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="back-end/node-js.html">Node.js</a>
    </li>
    <li>
      <a href="back-end/express-js.html">Express.js</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Miscellaneous
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="misc/js-libraries.html">JS libraries</a>
    </li>
    <li>
      <a href="misc/js-testing.html">JS Testing</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Vue.js</h1>

</div>


<p>A Vue.js a React és Angular alternatívája, amely ugyancsak egy olyan
JS framework, amely lehetővé teszi, hogy könnyebben hozzunk létre
komplex webes alkalmazásokat. A Vue.js reaktivitást ad a html
dokumentumokhoz a direktívák segítségével, amelyekkel bizonyos
megjelenített tartalmakat változókhoz köthetünk, illetve függvényeket
élesíthetünk.</p>
<div id="projektek-létrehozása" class="section level2">
<h2>Projektek létrehozása</h2>
<p>Egyszerűbb projektekhez a html file-ba illesztett CDN scripttel
adhatjuk hozzá, amelyet megtalálunk a <a
href="https://vuejs.org/v2/guide/installation.html#CDN">Vue.js
honlapon</a>. Ezt a JS scriptünk elé kell beilleszteni, hogy utóbbi már
hozzáférjen az ebben foglaltakhoz.</p>
<div id="app-objektum-létrehozása-és-hozzákapcsolása-a-html-file-hoz"
class="section level3">
<h3>App objektum létrehozása és hozzákapcsolása a html file-hoz</h3>
<p>Ha beillesztettük a megfelelő scriptet a html file-ba és a .js file-t
is hozzákötöttük, a .js file-ban létrehozható a Vue alkalmazás objektum.
Ehhez adhatunk data property-ket és metódusokat. Ha <code>.vue</code>
file-okat használunk, ezekben egymás mellett létrehozhatjuk a html
template-eket, a Vue alkalmazás objektumot és a css deklarációkat.</p>
<p>Az alkalmazásnak a <code>.mount(id)</code> metódussal tehetjük
lehetővé, hogy a html file bizonyos részeit kezelje. Érdemes id-t
használni, mert az egyedi. Class esetén az első találathoz köti.</p>
<p>Egy html file-hoz több alkalmazást is létrehozhatunk, amelyek
különböző részeit kezelik. Minden alkalmazás csak a saját adataihoz és
metódusaihoz fér hozzá. Ugyanakkor egy html részt csak egy app kezelhet,
és egy app csak a html egy részét kezelheti.</p>
<p>A mount révén az html kód adott részét a Vue app
<code>template</code>-jévé tesszük. A leggyakoribb és legegyszerűbb mód
kis alkalmazások esetén a html kódot a html file-ban megírni, és
hozzákötni az alkalmazást.</p>
<p>A template viszont az app részeként is létrehozható.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="kw">const</span> app <span class="op">=</span> Vue<span class="op">.</span><span class="fu">createApp</span>({</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="dt">template</span><span class="op">:</span> <span class="vs">`</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="vs">    &lt;p&gt;{{ text }}&lt;/p&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="vs">  `</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  <span class="fu">data</span>() {</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>      <span class="co">// Data properties</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>    }</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>  <span class="dt">methods</span><span class="op">:</span> {}</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>})</span></code></pre></div>
<p>Komplexebb projekteknél a template a vue file
<code>&lt;template&gt;</code> tagon belül hozható létre.</p>
</div>
<div id="vue-cli-és-vetur" class="section level3">
<h3>Vue CLI és Vetur</h3>
<p>Bonyolultabb projektekhez két lehetőség közül választhatunk.</p>
<p>Az egyik kombináció a Vue CLI és a VS Code Vetur kiegészítőjének
kombinációja. Használatához a Node.js-re van szükségünk. Ezután
telepíthetjük a Vue CLI-t:</p>
<pre><code>npm install -g @vue/cli</code></pre>
<p>Ezután létrehozhatjuk az alkalmazásunkat:</p>
<pre><code>vue create app-name</code></pre>
<p>A kérdésekre válaszolva kiválaszthatjuk, milyen beállításokkal (pl.
Vue verzió) szeretnénk létrehozni. Ha a feature-ök manuális kiválasztása
mellett döntünk, kijelölhetjük, melyeket szeretnénk használni, majd
kiválaszthatjuk a verziót. A többi kérdésre megelégedhetünk a default
válaszokkal.</p>
<p>Ezután a könyvtárba lépve elindíthatjuk a web development
servert:</p>
<pre><code>cd app-name
npm run serve</code></pre>
<p>A Vetur a VS Code bővítménye, amely segíti a fejlesztést, pl.
javaslatokkal, hibák jelzésével.</p>
</div>
<div id="npm-init-vue-és-volar" class="section level3">
<h3>npm init vue és Volar</h3>
<p>A másik lehetőség az <code>npm init vue</code> parancs használata a
projekt létrehozása. Ebben az esetben a VS Code-ban a Volar bővítményt
érdemes telepíteni.</p>
</div>
<div id="projektek-és-.vue-file-ok-struktúrája" class="section level3">
<h3>Projektek és .vue file-ok struktúrája</h3>
<p>Hasonlóan a React projekt struktúrához, a Vue projektek is külön
file-okban létrehozott komponensekből épülnek fel. Ezeket
<code>.vue</code> kiterjesztésű file-okban hozzuk létre, amelyek három
komponenst is tartalmazhatnak:</p>
<pre><code>&lt;template&gt;
  Ide jön a reaktív html
&lt;/template&gt;

&lt;script&gt;
  Ide jön a Vue objektum definíciója, amely az alkalmazást működteti
&lt;/script&gt;

&lt;style&gt;
  Ide jönnek a stílus deklarációk
&lt;/style&gt;</code></pre>
<p>Maga a fő html egyszerű struktúrájú, mint a React esetében is: egy
<code>app</code> id-vel rendelkező, eredetileg üres div-ből áll. Egy
tipikusan <code>main.js</code> nevű JavaScript file-ban építjük fel és
kötjük az alkalmazásunkat az app div-hez. Ezeket automatikusan
létrehozza a CLI.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="im">import</span> { createApp } <span class="im">from</span> <span class="st">&quot;vue&quot;</span><span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="im">import</span> App <span class="im">from</span> <span class="st">&quot;./App.vue&quot;</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="im">import</span> FriendsList <span class="im">from</span> <span class="st">&quot;./components/FriendsList.vue&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="kw">const</span> app <span class="op">=</span> <span class="fu">createApp</span>(App)</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>app<span class="op">.</span><span class="fu">component</span>(FriendsList)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>app<span class="op">.</span><span class="fu">mount</span>(<span class="st">&quot;app&quot;</span>)</span></code></pre></div>
<p>A komponenseket jellemzően a <code>components</code> mappában,
esetleg annak almappáiban hozzuk létre: minden file egy komponens. A
komponensek neve PascalCase formátumú szokott lenni.</p>
</div>
</div>
<div id="vue-működése" class="section level2">
<h2>Vue működése</h2>
<p>A Vue a JavaScript Proxy funkcióján alapul. Ez lehetővé teszi, hogy
bizonyos értékeket más változóértékek megváltoztatása hatására szintén
megváltoztassunk.</p>
<p>Akárcsak a React.js, a Vue.js is virtuális DOM-ot használ, és csak
azokat a DOM elemeket rendereli újra, amelyek változnak a korábbi
állapothoz képest.</p>
<div id="todo-proxy-részletek" class="section level3">
<h3>TODO (Proxy részletek)</h3>
</div>
<div id="vue-style-guide" class="section level3">
<h3>Vue Style Guide</h3>
<p>A Vue kóddal kapcsolatos elvárásokat, ajánlásokat a hivatalos Vue.js
Style Guide tartalmazza, amely elérhető a Vue.js honlapot, <a
href="https://vuejs.org/style-guide/">itt</a>.</p>
</div>
</div>
<div id="komponensek" class="section level2">
<h2>Komponensek</h2>
<p>Bonyolultabb alkalmazásokat modulárisan hozunk létre: a komponensek
külön file-okban vannak definiálva, html template-jükkel és
stílusdeklarációikkal együtt. A komponens file-ok tartalmaznak egy
template részt, amely a html felépítést adja meg. Emellett, ha JS logika
kötődik hozzájuk, tartalmaznak egy script részt, amelybe kerülnek az
importok, illetve itt definiáljuk az exportált komponens objektumot is.
Ezen kívül kaphatnak stílus deklarációkat a style tag segítségével:</p>
<pre><code>&lt;template&gt;
  &lt;!-- html --&gt;
&lt;/template&gt;

&lt;script&gt;
  // JS
&lt;/script&gt;

&lt;style&gt;
  /* CSS */
&lt;/style&gt;</code></pre>
<p>A Vue3 már lehetővé teszi, hogy a komponens template-jében több
elemet is a legfelsőbb szinten, testvérként rendereljünk, ellentétben
például a React-tal, ahol szabály, hogy a renderelt komponensnek egy
elemből kell állnia a legfelső szinten (ez lehet fragment is, amely a
html-ben nem hoz létre új szintet).</p>
<div id="globális-komponensek" class="section level3">
<h3>Globális komponensek</h3>
<p>Ha azt szeretnénk, hogy a komponensek az egész alkalmazásban
használhatók legyenek, Importálni tudjuk őket a fő JS file-ba
(<code>main.js</code>) és használni tudjuk bármelyik komponensben, ha az
importált komponenst az
<code>app.component('element-name', ComponentName)</code> paranccsal az
alkalmazás rendelkezésére bocsátjuk.</p>
<p>A komponenst a szülő file-jában speciális html-tagként tudjuk
használni.</p>
<p>A globális komponensekkel a probléma, hogy bizonyos nagyobb
alkalmazásoknál egyes komponensek nem is feltétlenül jelennek meg a
használat során (pl. hibaüzenet). A böngésző azonban mégis minden egyes
komponenst letölt az oldal megnyitásakor. Emellett ebben az esetben nem
egyértelmű a programkódból, melyik komponenst hol is használjuk.</p>
</div>
<div id="lokális-komponensek" class="section level3">
<h3>Lokális komponensek</h3>
<p>Ha a létrehozott komponenseket csak egy helyen, egy komponensen belül
használjuk, akkor lokálisan is regisztrálhatjuk ezeket: ehhez a
komponens (ez lehet az App.vue is) script részében importáljuk ezeket,
és az objektumon létrehozzuk a <code>components</code> property-t,
amelynek értéke egy objektum, amely tartalmazza a használni kívánt
komponenseket.</p>
<p>Ezeket többféleképpen megadhatjuk: a key lehet kebab-case-ben és
PascalCase-ben is, az érték pedig az importált komponens objektum:</p>
<pre><code>export default {
 // ...
 components: {
  &#39;element-one&#39;: ElementOne,
  ElementTwo: ElementTwo,
  ElementThree
}
}</code></pre>
<p>Ezek után a template-ben használhatjuk a
<code>&lt;element-name&gt;&lt;/element-name&gt;</code> vagy
<code>&lt;ElementName /&gt;</code> formát egyaránt, függetlenül attól,
hogyan regisztráltuk.</p>
</div>
<div id="az-appkomponens-objektum" class="section level3">
<h3>Az App/komponens objektum</h3>
<p>A Vue script logikáját az App/komponens objektum tartalmazza, akár
kisebb, akár komplex projektekről van szó. Ezen hozhatjuk létre a
különböző property-ket, illetve metódusokat, amelyekkel a Vue program
működési logikáját felépítjük. A .vue file-okban ez a
<code>script</code> tag-be kerül.</p>
<p>A legfontosabbak a data, methods, props property-k és mások.</p>
<div id="data-property" class="section level4">
<h4>Data property</h4>
<p>Azokat a változókat, amelyeket a html file-ban szeretnénk használni,
a Vue alkalmazás data() függvényében adhatjuk meg. Ez a függvény egy
objektumot ad eredményként, amelyben az egyes property-k elérhetők
lesznek a metódusok és a Vue által kezelt html file számára.</p>
</div>
<div id="metódusok" class="section level4">
<h4>Metódusok</h4>
<p>A Vue alkalmazás részeként létrehozhatunk metódusokat is, amelyeket
szintén felhasználhatunk a html-ben. Ezeket a methods property alatt egy
objektum metódusaiként adhatjuk meg (ES6 rövidített formában is). A
metódusban az adatokra a <code>this.propertyName</code> formában tudunk
hivatkozni.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="kw">const</span> app <span class="op">=</span> Vue<span class="op">.</span><span class="fu">createApp</span>({</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>  <span class="co">// Takes a function and returns an object</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  <span class="co">// will be properties of Vue global object</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  <span class="fu">data</span>() {</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>      <span class="dt">courseGoalA</span><span class="op">:</span> <span class="st">&quot;Finish the course and learn Vue!&quot;</span><span class="op">,</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>      <span class="dt">courseGoalB</span><span class="op">:</span> <span class="st">&quot;Master Vue and build amazing apps!&quot;</span><span class="op">,</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>      <span class="dt">courseGoalHtml</span><span class="op">:</span> <span class="st">&quot;&lt;h3&gt;Learn a lot of important features&lt;/h3&gt;&quot;</span><span class="op">,</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>      <span class="dt">vueLink</span><span class="op">:</span> <span class="st">&quot;https://vuejs.org/&quot;</span><span class="op">,</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>    }<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a>  <span class="dt">methods</span><span class="op">:</span> {</span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a>    <span class="fu">outputGoal</span>() {</span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a>      <span class="kw">const</span> randomNumber <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">random</span>()<span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a>      <span class="cf">if</span> (randomNumber <span class="op">&lt;</span> <span class="fl">0.5</span>) {</span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">this</span><span class="op">.</span><span class="at">courseGoalA</span><span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a>      } <span class="cf">else</span> {</span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">this</span><span class="op">.</span><span class="at">courseGoalB</span><span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" tabindex="-1"></a>      }</span>
<span id="cb9-20"><a href="#cb9-20" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb9-21"><a href="#cb9-21" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb9-22"><a href="#cb9-22" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
</div>
<div id="computed-property" class="section level4">
<h4>Computed property</h4>
<p>Bizonyos esetekben a változóértéket nem közvetlenül (pl. inputból)
kapjuk, hanem számítjuk. Ilyen esetekben, ha a kapott eredményt nem
eventhez kötve, hanem interpolationnel szeretnénk megjeleníteni, jobb
nem metódusokat használni, mert ezek az oldal minden újrarenderelésénél
újra lefutnak, mert a Vue nem tudhatja, milyen egyéb adatokon
alapulnak.</p>
<p>Ehelyett lehetőség van számított property-ket megadni, amelyek csak
akkor futnak újra, ha valamelyik feltételük megváltozott.</p>
<p>Ezeket metódusként hozzuk létre, de ugyanúgy hivatkozhatunk rájuk
(zárójel nélkül), mint a sima data property-kre.</p>
</div>
<div id="watchers" class="section level4">
<h4>Watchers</h4>
<p>Hasznos funkció, hogy bizonyos változókat figyelhetünk, és ha ezek
valamilyen adott feltételnek megfelelnek, akkor futtathatunk egy
metódust. Ehhez a watcher metódust ugyanúgy nevezzük el, mint a
megfigyelt változót. Ez a metódus automatikusan hozzáférést kap (a Vue
argumentumként megadja) a változó aktuális értékéhez.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">const</span> app <span class="op">=</span> Vue<span class="op">.</span><span class="fu">createApp</span>({</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  <span class="fu">data</span>() {</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>      <span class="dt">counter</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>      <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;&quot;</span><span class="op">,</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>      <span class="dt">lastName</span><span class="op">:</span> <span class="st">&quot;&quot;</span><span class="op">,</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>    }<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>  <span class="dt">watch</span><span class="op">:</span> {</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>    <span class="fu">counter</span>(value) {</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>      <span class="cf">if</span> (value <span class="op">&gt;</span> <span class="dv">50</span>) {</span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span><span class="at">counter</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a>      }</span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a>  <span class="dt">computed</span><span class="op">:</span> {</span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a>    <span class="fu">fullname</span>() {</span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>      <span class="cf">if</span> (<span class="kw">this</span><span class="op">.</span><span class="at">name</span> <span class="op">===</span> <span class="st">&quot;&quot;</span> <span class="op">||</span> <span class="kw">this</span><span class="op">.</span><span class="at">lastName</span> <span class="op">===</span> <span class="st">&quot;&quot;</span>) {</span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>      }</span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">this</span><span class="op">.</span><span class="at">name</span> <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> <span class="kw">this</span><span class="op">.</span><span class="at">lastName</span><span class="op">;</span></span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a>  <span class="dt">methods</span><span class="op">:</span> {</span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a>    <span class="fu">setName</span>(<span class="bu">event</span>) {</span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a>      <span class="kw">this</span><span class="op">.</span><span class="at">name</span> <span class="op">=</span> <span class="bu">event</span><span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a>    <span class="fu">add</span>(num) {</span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a>      <span class="kw">this</span><span class="op">.</span><span class="at">counter</span> <span class="op">+=</span> num<span class="op">;</span></span>
<span id="cb10-30"><a href="#cb10-30" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb10-31"><a href="#cb10-31" tabindex="-1"></a>    <span class="fu">reduce</span>() {</span>
<span id="cb10-32"><a href="#cb10-32" tabindex="-1"></a>      <span class="kw">this</span><span class="op">.</span><span class="at">counter</span><span class="op">--;</span></span>
<span id="cb10-33"><a href="#cb10-33" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb10-34"><a href="#cb10-34" tabindex="-1"></a>    <span class="fu">resetInput</span>() {</span>
<span id="cb10-35"><a href="#cb10-35" tabindex="-1"></a>      <span class="kw">this</span><span class="op">.</span><span class="at">name</span> <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb10-36"><a href="#cb10-36" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb10-37"><a href="#cb10-37" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb10-38"><a href="#cb10-38" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
</div>
<div id="custom-property-k-props-ok" class="section level4">
<h4>Custom property-k (Props-ok)</h4>
<p>A szülő komponens a gyermekkel propok révén kommunikál (hasonlóan a
Reacthoz). Ez a kommunikáció egyirányú, tehát a kapott propokat nem
lehet módosítani, legfeljebb annyit tehetünk, hogy kezdeti értékként
kezeljük, és a másolatát módosítjuk, amire az alkalmazás reagál.</p>
<p>A propok neveit <code>kebab-case</code> formában adjuk meg a
template-ekben, az alkalmazás objektumban pedig <code>camelCase</code>
formában férünk hozzájuk. Közvetlenül string értékeket adhatunk át,
illetve a <code>v-bind:prop-name="jsExpression"</code> (röviden
<code>:prop-name</code>) révén nem string értékeket is.</p>
<p>A propokat validálhatjuk is: megadhatjuk, milyen típusúaknak kell
lenniük, és megadhatjuk, mely propok szükségesek.</p>
<pre><code>props: {
    id: {
      type: String,
      required: true,
    },
    // name: String
    name: {
      // Can be any constructor function
      type: String,
      required: true,
    },
    phoneNumber: {
      type: String,
      required: true,
    },
    emailAddress: {
      type: String,
      required: true,
    },
    isFavorite: {
      type: Boolean,
      required: false,
      default: false,
    }
}</code></pre>
<p>Ha sok propot adunk meg, akkor ezeket továbbíthatjuk objektumba
csomagolva is.</p>
</div>
<div id="custom-eventek-emits-property" class="section level4">
<h4>Custom eventek, emits property</h4>
<p>A gyermek komponens a szülő felé saját események élesítésével tud
kommunikálni. Ehhez létrehozhatunk egy metódust az objektumon, amely
ilyen saját eventet élesít: a
<code>this.$emit('custom-event', dataArguments)</code> paranccsal, ahol
megadhatunk továbbítandó argumentumokat is. Ezeket a speciális
eseményeket ugyanúgy kezelhetjük a szülő komponensben, mint a
beépítetteket: a gyermek komponenshez adott <code>v-on</code> vagy
<code>@</code> direktíva révén.</p>
<p>A komponens által élesített eseményeket az objektumon belül az emits
key-hez adhatjuk, array-ként vagy objektumként, amely esetben
validálhatjuk is ezeket: ha teljesül minden feltétel, akkor
<code>true</code>-nak, ha pedig valami probléma van,
<code>false</code>-nak kell lennie a return értéknek.</p>
<pre><code>emits: {
    &quot;toggle-favorite&quot;: function (id) {
      if (id) {
        return true;
      } else {
        console.warn(&quot;Id is missing.&quot;);
        return false;
      }
    },
  },</code></pre>
<p>Ezeket közvetlenül is létrehozhatjuk a megfelelő elemen, metódus
nélkül:
<code>&lt;button @click="$emit('delete', id)"&gt;Delete&lt;/button&gt;</code>,
de az emits array-be (objektumba) ekkor is beleírhatjuk, hogy
egyértelművé tegyük, milyen eseményeket élesít a komponens.</p>
</div>
<div id="prop-event-fallthrough" class="section level4">
<h4>Prop / event fallthrough</h4>
<p>Ha egy custom komponens csak egy root komponenst (pl. egy gombot)
generál, akkor a custom komponensnek megadott egyes propok öröklődnek,
és ugyanígy, a root komponens által élesített eseményeket figyelhetjük a
custom komponensen. Tehát pl. a class propot megkapja a gyermek, és a
click eseményt felveszi a szülő is.</p>
</div>
<div
id="propok-és-eventek-több-szinten-át-való-továbbítása-provide-és-inject"
class="section level4">
<h4>Propok és eventek több szinten át való továbbítása: provide és
inject</h4>
<p>Vannak esetek, amikor a propokat, illetve az eseményeket csak
továbbítunk néhány szinten keresztül. Ilyen esetekben a
továbbküldözgetést kiválthatjuk a <code>provide</code> és
<code>inject</code> segítségével.</p>
<p>A <code>provide</code> az app vagy komponens objektumhoz adott
property-ként adatokat tud továbbítani, a <code>provide()</code>
függvényként pedig az objektum adatai, illetve metódusai közül is
továbbíthat. Ehhez a függvény egy objektumot ad return értékként,
amelynek property-jeihez kötjük az egyes adat attribútumokat vagy
metódusokat.</p>
<pre><code>provide() {
    return {
      topics: this.topics,
      selectTopic: this.activateTopic,
    };
  },</code></pre>
<p>Az így rendelkezésre bocsátott adatokhoz és metódusokhoz a közvetlen
vagy közvetett gyermekek férhetnek hozzá. Ehhez ezeken létre kell hozni
az <code>inject</code> property-t, amelyhez egy array-t kötünk, amelyben
megadjuk, milyen továbbított adatokat vagy metódusokat fogad. Pl.
<code>inject: ['topics', 'selectTopic']</code>. Ezeket aztán ugyanúgy
használhatjuk az objektumban, mint a saját adatokat, illetve
propokat.</p>
<p>Ha a továbbított függvényt argumentumokkal akarjuk hívni, Vue-ban
erre is van lehetőség, nem csak a függvény objektumra mutatni:
<code>@click="selectTopic(id)"</code></p>
<p>A provide/inject esetében viszont arra kell figyelni, hogy ha a
renderelést követően új objektummal helyettesítjük a provide-dal
továbbított objektumot (pl. array-t), a gyermek komponensek továbbra is
az eredetire mutató hivatkozáshoz férnek hozzá, és így pl. nem frissül
az UI.</p>
</div>
</div>
<div id="testre-szabható-wrapper-komponensek-slotok"
class="section level3">
<h3>Testre szabható wrapper komponensek, slotok</h3>
<p>Néha újrahasznosítható wrapper komponenseket szeretnénk létrehozni,
amelyeket változatos tartalmakkal szeretnénk feltölteni: pl. Card
komponens. Ehhez használhatjuk a slot funkciót. Létrehozzuk a komponens
template-jét és stílusait, majd arra a helyre, ahová a html tartalmat
szeretnénk illeszteni a <code>&lt;slot&gt;&lt;/slot&gt;</code> elemet
illesztjük.</p>
<p>Ha ezek után valahol a komponenst használjuk, és a nyitó és zárótag
közé html tartalmat írunk, azt a slot helyére illeszti be.</p>
<pre><code>// BaseCard.vue

&lt;template&gt;
  &lt;div&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

// UserInfo.vue

&lt;template&gt;
  &lt;section&gt;
    &lt;base-card&gt;
      &lt;header&gt;
        &lt;h3&gt;{{ fullName }}&lt;/h3&gt;
        &lt;base-badge :type=&quot;role&quot; :caption=&quot;role.toUpperCase()&quot;&gt;&lt;/base-badge&gt;
      &lt;/header&gt;
      &lt;p&gt;{{ infoText }}&lt;/p&gt;
    &lt;/base-card&gt;
  &lt;/section&gt;
&lt;/template&gt;
</code></pre>
<div id="nevesített-és-default-slotok" class="section level4">
<h4>Nevesített és default slotok</h4>
<p>Ha több slotot szeretnénk használni, a slotokat
<strong>nevesíthetjük</strong> is. Legfeljebb egyet hagyhatunk név
nélkül, ez lesz az alapértelmezett (<em>default</em>).</p>
<p>A nevesített slotba a <template> taggel illeszthetünk be, amelyhez
speciális direktívát adunk: <code>v-slot:name</code> formában. Enek
rövidített formája a <code>#name</code>. A template maga nem hoz létre
html elemet.</p>
<p>Minden nem template-be helyezett tartalom a default slotba kerül, de
ezt egyértelművé is tehetjük, ha
<code>&lt;template v-slot:default&gt;&lt;/template&gt;</code> tagek közé
tesszük.</p>
<pre><code>// BaseCard.vue

&lt;template&gt;
  &lt;div&gt;
    &lt;header&gt;
      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
    &lt;/header&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

// UserInfo.vue

&lt;template&gt;
  &lt;section&gt;
    &lt;base-card&gt;
      &lt;template v-slot:header&gt;
        &lt;h3&gt;{{ fullName }}&lt;/h3&gt;
        &lt;base-badge :type=&quot;role&quot; :caption=&quot;role.toUpperCase()&quot;&gt;&lt;/base-badge&gt;
      &lt;/template&gt;
      &lt;p&gt;{{ infoText }}&lt;/p&gt;
    &lt;/base-card&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<p>Ha a felhasznált komponensben csak egy default slot van, a
felhasználáskor nem kell a template elemet használni, hanem közvetlenül
a custom komponens tagjében megadhatunk minden propot (ld. alább a
CourseGoals-nál).</p>
<p>A slotok egyes részeinek renderelését feltételhez is köthetjük. Az
alábbi BaseCard template-ből a header rész csak akkor renderelődik, ha
van tartalma. Ezt a header elemhez adott v-if attribútummal érhetjük el.
A slotok tartalmához a beépített <code>$slots</code> objektum révén
férünk hozzá, amelyen minden slot tartalma property-ként jön létre
automatikusan.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="kw">&lt;template&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>  <span class="kw">&lt;div&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>    <span class="kw">&lt;header</span> <span class="er">v-if</span><span class="ot">=</span><span class="st">&quot;$slots.header&quot;</span><span class="kw">&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>      <span class="kw">&lt;slot</span> <span class="er">name</span><span class="ot">=</span><span class="st">&quot;header&quot;</span><span class="kw">&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>        <span class="co">&lt;!-- &lt;h2&gt;The Default content&lt;/h2&gt; --&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>      <span class="kw">&lt;/slot&gt;</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>    <span class="kw">&lt;/header&gt;</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>    <span class="kw">&lt;slot&gt;&lt;/slot&gt;</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>  <span class="kw">&lt;/div&gt;</span></span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a><span class="kw">&lt;/template&gt;</span></span></code></pre></div>
<p>A slotba küldött tartalomban hozzáférünk a felhasználó komponens
minden adatához és metódusához. A stílusokat viszont a wrapper
komponensnél tudjuk deklarálni.</p>
</div>
<div id="scoped-slots-adattovábbítás" class="section level4">
<h4>Scoped slots: adattovábbítás</h4>
<p>Problémát jelenthet, ha például a komponenst úgy szeretnénk
kialakítani, hogy a felhasználás helyén megszabhassák a tartalom
formáját is, de azt szeretnénk, hogy itt is hozzáférjenek a slotot
létrehozó komponens adataihoz. Például az alábbi CourseGoals
komponensnél meg akarjuk hagyni a lehetőséget, hogy ahol beillesztjük,
adhassuk meg, hogy néz ki. A felhasznált adatokhoz (goals array) azonban
a CourseGoals komponens fér hozzá, az App komponens, ahol használjuk,
nem. Ilyenkor az adatokat a props-hoz hasonlóan meg tudjuk adni a sloton
(ezt hívjuk <code>scoped slot</code>-nak), és ezekhez a felhasználási
helyen, a slothoz tartozó template-ben hozzá tudunk férni egy objektum
részeként. Ehhez a template objektumon (vagy, ha csak egy default slot
van, és nem kell template, magán a custom komponensen) megadjuk a
<code>v-slot="slotProps"</code> (vagy
<code>#slotName="slotProps"</code>) attribútumot, és ekkor a
slotProps.propName formában férünk hozzá a továbbított adatokhoz.</p>
<pre><code>// CourseGoals.vue
&lt;template&gt;
  &lt;ul&gt;
    &lt;li v-for=&quot;goal in goals&quot; :key=&quot;goal&quot;&gt;
      &lt;slot :item=&quot;goal&quot; another-prop=&quot;...&quot;&gt;&lt;/slot&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      goals: [&quot;Finish the course&quot;, &quot;Learn vue&quot;],
    };
  },
};
&lt;/script&gt;


// App.vue (részlet)
&lt;template&gt;
  &lt;div&gt;
    ...
    &lt;course-goals #default=&quot;slotProps&quot;&gt;
      &lt;!-- Get access to object with all prop values --&gt;
      &lt;h2&gt;{{ slotProps.item }}&lt;/h2&gt;
      &lt;p&gt;{{ slotProps[&quot;another-prop&quot;] }}&lt;/p&gt;
    &lt;/course-goals&gt;
    ...
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>Bizonyos esetekben hasznos lehet, hogy a slotokat alapértelmezett
tartalommal is ellássuk. Ez csak akkor renderelődik, ha a felhasználási
helyen üresen hagyjuk a slot template-jét. A default tartalom egyszerűen
létrehozható: a slotot deklaráló file-ban megadjuk a tartalmat html
formában.</p>
</div>
</div>
<div id="dinamikus-komponensek-a-component-elem" class="section level3">
<h3>Dinamikus komponensek: a component elem</h3>
<p>Hasznos funkció a <code>component</code> beépített elem, amely
lehetővé teszi, hogy dinamikusan illesszünk be komponenseket. Ezeket,
akárcsak a más lokális komponenseket az objektum components property-jén
regisztráljuk, a beillesztés pedig a <code>&lt;component&gt;</code> tag
segítségével történik, amely <code>it</code> attribútumán megadhatjuk,
melyik komponenst szeretnénk ide renderelni.</p>
<p>Ez hasznos lehet például a tabok esetében. A kiválasztott tab nevét
egy data property-ben tároljuk, és ezt használjuk fel a
rendereléshez.</p>
<p>Ezeket a dinamikus komponenseket a váltáskor hozza létre, illetve a
korábbiakat megsemmisíti a böngésző, ezért a pl. félig kitöltött form
adatai elvesznek. Ez elkerülhető a <code>keep-alive</code> tag-ek
használatával.</p>
<pre><code>&lt;template&gt;
  &lt;base-card&gt;
    &lt;!-- Event fallthrough --&gt;
    &lt;base-button @click=&quot;setSelectedTab(&#39;stored-resources&#39;)&quot;&gt;
      Stored Resources
    &lt;/base-button&gt;
    &lt;base-button @click=&quot;setSelectedTab(&#39;add-resource&#39;)&quot;&gt;
      Add Resource
    &lt;/base-button&gt;
  &lt;/base-card&gt;
  
  
  &lt;!-- DYNAMIC COMPONENT --&gt;
  &lt;keep-alive&gt;
    &lt;component :is=&quot;selectedTab&quot;&gt;&lt;/component&gt;
  &lt;/keep-alive&gt;
&lt;/template&gt;

&lt;script&gt;
import StoredResources from &#39;./StoredResources.vue&#39;;
import AddResource from &#39;./AddResource.vue&#39;;

export default {
  components: {
    StoredResources,
    AddResource,
  },
  data() {
    return {
      selectedTab: &#39;stored-resources&#39;,
    }
  },
  methods: {
    setSelectedTab(tab) {
      this.selectedTab = tab;
    },
  }
}
&lt;/script&gt;</code></pre>
<p>A dinamikus komponenseknek való adattovábbítás történhet propokkal:
ebben az esetben olyan komponenseknek is továbbítjuk a propokat, amelyek
esetleg nem is használják. Ebben az esetben a kozolon figyelmeztetést
kapunk. A másik lehetséges megoldás a provide/inject használata.</p>
</div>
<div id="teleport" class="section level3">
<h3>Teleport</h3>
<p>A komponensek részeit alapvetően a komponensen belül hozza létre a
böngésző, ahol a html-ben is szerepelnek. Ezt a teleport segítségével
felülírhatjuk, és pl. egy felugró ablakot a legfelső szinten (a
<code>body</code> tagben) is létrehozhatunk. Ehhez a teleportálandó
részt a <code>&lt;teleport&gt;</code> tagbe csomagoljuk, amelyhez a
<code>to="cssSelector"</code> attribútumot hozzáadva megadhatjuk, hová
szeretnénk renderelni.</p>
<pre><code>&lt;template&gt;
  &lt;teleport to=&quot;body&quot;&gt;
    &lt;div @click=&quot;$emit(&#39;close&#39;)&quot;&gt;&lt;/div&gt;
    &lt;dialog open&gt;
      &lt;header&gt;
        &lt;slot name=&quot;header&quot;&gt;
          &lt;h2&gt;{{ title }}&lt;/h2&gt;
        &lt;/slot&gt;
      &lt;/header&gt;
      &lt;section&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/section&gt;
      &lt;menu&gt;
        &lt;slot name=&quot;actions&quot;&gt;
          &lt;base-button @click=&quot;$emit(&#39;close&#39;)&quot;&gt;Close&lt;/base-button&gt;
        &lt;/slot&gt;
      &lt;/menu&gt;
    &lt;/dialog&gt;
  &lt;/teleport&gt;
&lt;/template&gt;</code></pre>
</div>
</div>
<div id="js-logika-a-html-template-ben" class="section level2">
<h2>JS logika a html template-ben</h2>
<p>A Vue alkalmazásokban a html szerkezet és a JavaScript logikát
kombinálhatjuk: a html template-eket változók felhasználásával tehetjük
dinamikusabbá, illetve eventeket élésíthetünk, amelyek különböző
metódusokat hívnak, stb.</p>
<p>Az alábbiak függetlenül attól érvényesek, hogy külön .html és .js
file-okkal dolgozunk (kisebb projekteknél), vagy a Vue.js saját .vue
file-jaival. Előbbi esetben a html és js file-ok közötti kommunikáció
zajlik így (a html file-nak csak azok a részei férnek hozzá a Vue
objektumok adataikhoz, amelyekre mountoltuk az alkalmazást), utóbbi
esetben pedig a vue file-ok template és script részei között zajlik a
kommunikáció.</p>
<div id="adatok-metódusok-és-propok-felhasználása"
class="section level3">
<h3>Adatok, metódusok és propok felhasználása</h3>
<p>Az alkalmazásban létrehozott adat property-k és metódusok, illetve a
fogadott propok felhasználása attól függ, hol történik.</p>
<p><strong>Html tagek tartalmaként</strong> való megjelenítésre az
interpolációt használhatjuk: <code>{{}}</code> közé írhatjuk az adott
adat vagy metódus nevét, illetve bármilyen JS kifejezést
(<em>expression</em>). Ha viszont a tartalom html tageket is tartalmaz,
akkor a nyitó tagbe illesztett <code>v-html="value"</code> formában
adhatjuk meg. Ez kevésbé jellemző, ehelyett a slot funkciót
használhatjuk, ha a html-t is szeretnénk alakítani.</p>
<p><strong>Html attribútumok</strong> (pl. href, src, value, stb.) a
<code>v-bind</code> segítségével kezelhetők:
<code>v-bind:attribute-name="value"</code> formában. Ennek rövidített
formája: <code>:attribute-name="value"</code>.</p>
<pre><code>&lt;body&gt;
    &lt;header&gt;
      &lt;h1&gt;Vue Course Goals&lt;/h1&gt;
    &lt;/header&gt;
    &lt;section id=&quot;user-goal&quot;&gt;
      &lt;h2&gt;My Course Goal&lt;/h2&gt;
      &lt;!-- Interpolation --&gt;
      &lt;p&gt;{{ courseGoalA }}&lt;/p&gt;
      &lt;!-- Call methods --&gt;
      &lt;p&gt;{{ outputGoal() }}&lt;/p&gt;
      &lt;!-- Output html content --&gt;
      &lt;p v-html=&quot;courseGoalHtml&quot;&gt;&lt;/p&gt;
      &lt;!-- &lt;p v-html=&quot;outputGoal()&quot;&gt;&lt;/p&gt; --&gt;
      &lt;!-- Bind data to attributes --&gt;
      &lt;p&gt;Learn more &lt;a v-bind:href=&quot;vueLink&quot;&gt;about Vue&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/body&gt;</code></pre>
</div>
<div id="feltételes-renderelés" class="section level3">
<h3>Feltételes renderelés</h3>
<p>Ha a DOM egyes részeit csak bizonyos feltétel esetén szeretnénk
renderelni, használhatjuk a <code>v-if</code> direktívát, szükség esetén
a <code>v-else-if</code> és <code>v-else</code> direktívákkal együtt, de
utóbbiak csak közvetlenül a <code>v-if</code> után jöhetnek, testvér
elemeken.</p>
<pre><code>&lt;p v-if=&quot;goals.length === 0&quot;&gt;No goals have been added yet - please start adding some!&lt;/p&gt;
&lt;p v-else-if=&quot;goals.length === 1&quot;&gt;Please add more goals!&lt;/p&gt;
&lt;ul v-else&gt;
  &lt;li&gt;...&lt;/li&gt;
  ...
&lt;/ul&gt;</code></pre>
</div>
<div id="listák-renderelése" class="section level3">
<h3>Listák renderelése</h3>
<p>Ha egy array, vagy objektum minden eleméhez, vagy egy számsor minden
értékéhez rendelni akarunk egy elemet, a <code>v-for</code> direktívát
használhatjuk. Ha array-ön használjuk, az adott elemhez, és az indexéhez
férünk hozzá, ha objektumon, akkor az értékhez, a kulcshoz és az
indexhez. Ezekhez hozzáférnek az adott html elem attribútumai, és a
tartalma.</p>
<p>Listák renderelésénél, hogy a Vue meg tudja különböztetni az
elemeket, a key speciális attribútumot kell használni, hogy a
listaelemeket egyedi kulccsal ellássuk.</p>
<pre><code>&lt;ul&gt;
    &lt;li v-for=&quot;(goal, index) in goals&quot; :key=&quot;goal&quot; @click=&quot;removeGoal(index)&quot;&gt;
        &lt;p&gt; {{ index }}: {{ goal }} &lt;/p&gt;
    &lt;/li&gt;
    &lt;li v-for=&quot;(value, key, index) in { name: &#39;John&#39;, age: 25 }&quot;&gt;{{key}}: {{ value }}&lt;/li&gt;
    &lt;li v-for=&quot;num in 10&quot;&gt;{{ num }}&lt;/li&gt;
&lt;/ul&gt;</code></pre>
</div>
<div id="eventek" class="section level3">
<h3>Eventek</h3>
<p>A Vue az eventek hozzáadását is könnyű teszi a
<code>v-on:eventName</code> szintaxis révén. Ennek rövidített változata
<code>@eventName</code>. A Vue ismer beépített eventeket (pl. click,
dblclick, submit), de saját eventek is létrehozhatók és élesíthetők (ld.
később)</p>
</div>
</div>
<div id="formok-és-inputok-kezelése" class="section level2">
<h2>Formok és inputok kezelése</h2>
<p>Adatlap inputok esetében lehetséges az adatok beolvasása event
handler révén, pl. az <code>input</code> vagy <code>keyup</code> eventek
használatával, és az input értékét (a value attribútummal)
összeköthetjük az adott data property-vel, így létrehozva a two-way
bindingot, de a Vue.js ezt a két dolgot egy külön direktívával
összeköti, és könnyebbé teszi az input értékek data property-be
mentését.</p>
<p>Ez a <code>v-model</code> direktíva. Ez egy data property-t kap
értékként, és metódusra már nincs is szükség a beolvasáshoz. Ráadásul
így a data property felülírásával egyúttal az input értékét is
változtatjuk (pl. törölni tudjuk a beírt szavakat)</p>
<pre><code>&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;</code></pre>
<p>Ezek a megoldások minden leütésnél frissítik az adott data
property-t. Ez jó lehet, ha minden leütésnél validálni akarunk.</p>
<div id="v-model-különböző-típusú-inputoknál" class="section level3">
<h3>v-model különböző típusú inputoknál</h3>
<p><strong>Text</strong> inputoknál evidens, hogy string típusú értéket
kapunk. <strong>Number</strong> típusú inputnál a v-model számot
eredményez. Ha ezt kényszeríteni akarjuk (pl. text input esetében is
megtehetjük), a <code>v-model</code>-hez hozzadhatjuk a
<code>.number</code> módosítást.</p>
<p>Egy másik modifier a <code>.trim</code>, amely lehetővé teszi, hogy a
szóeleji és szóvégi space-eket töröljük, és azok nélkül mentsük az
értéket.</p>
<p>A v-model <strong>dropdown</strong> típusú input elemekkel
(<code>&lt;select&gt;</code>) is működik: a v-modelt a select elemhez
adjuk, az értéke pedig a kiválasztott <code>option</code> value értéke
lesz. Ebben az esetben a kiinduló érték, amit a data property-ben
mentünk ne üres legyen, hanem az alapértelmezett opció, amelyet először
ott szeretnénk látni.</p>
<p><strong>Checkbox</strong> input esetén a v-model direktívát minden
opcióhoz hozzáadjuk, és ugyanarra az adat property-re mutat mind. A
kezdeti értéket array-ként kell megadni, ehhez adja hozzá a bejelölt
inputok értékeit. Ahhoz, hogy ez működjön, az inputoknak rendelkezniük
kell <code>value</code> attribútumértékkel.</p>
<p>Ha csak egy checkbox van (pl. felhasználási feltételek elfogadása),
akkor a v-modellel Boolean értéket kapunk attól függően, hogy be van-e
pipálva.</p>
<p>Ugyanígy a <strong>radio button</strong> inputnál is meg kell adni a
value attribútumértékeket, és a v-model direktívát minden egyes radio
elemhez hozzá kell adni, azonos data property-vel. A kezdeti érték
<code>null</code> lehet.</p>
</div>
<div id="ref" class="section level3">
<h3>Ref</h3>
<p>Az inputhoz (és bármilyen más html elemhez) hozzáadható egy
<code>ref</code> attribútum.</p>
<pre><code>&lt;input type=&quot;text&quot; ref=&quot;inputText&quot;&gt;</code></pre>
<p>Ez létrehoz egy speciális property-t a Vue alkalmazás objektumon,
amelyhez a <code>$refs</code> property névvel férhetünk hozzá. Ez maga
is egy objektum, amelyen a megadott stringekkel jelölt property-k jönnek
létre. Ezek az egész html elem objektumot tartalmazzák. Ennek lehet pl.
<code>value</code> property-je.</p>
<p><strong>Fontos:</strong> Ha number inputhoz adjuk is, akkor is string
értéket kapunk.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="kw">const</span> app <span class="op">=</span> Vue<span class="op">.</span><span class="fu">createApp</span>({</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>  <span class="fu">data</span>() {}<span class="op">,</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>  <span class="dt">methods</span><span class="op">:</span> {</span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>    <span class="fu">setText</span>() {</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>      <span class="kw">this</span><span class="op">.</span><span class="at">message</span> <span class="op">=</span> <span class="kw">this</span><span class="op">.</span><span class="at">$refs</span><span class="op">.</span><span class="at">inputText</span><span class="op">.</span><span class="at">value</span></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>    }</span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>  }</span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a>})</span></code></pre></div>
</div>
<div id="form-kezelése" class="section level3">
<h3>Form kezelése</h3>
<p>Default html viselkedés, hogy ha form elemen belül gomb van, akkor az
arra való kattintás elküldi az adatokat. Ezeket a frontenden is kezelni
tudjuk, ehhez azonban az alapértelmezett viselkedést le kell tiltani. A
formon a submit eseményt figyelhetjük. Ehhez hozzáadhatjuk a
<code>.prevent</code> beépített metódust, hogy letiltsuk az
alapértelmezett viselkedést, és ezután egy saját függvénnyel kezelhetjük
az adatokat, illetve élesíthetünk pl. saját eseményt is.</p>
<p><code>&lt;form @submit.prevent="funName"&gt;</code></p>
</div>
<div id="input-validáció" class="section level3">
<h3>Input validáció</h3>
<p>Alap validációra jó megoldás lehet, hogy a submit által élesített
metódusban, ha valamelyik input értéke nem felel meg (pl. üres), nem
rögzítjük az adatokat, hanem figyelmeztetést jelenítünk meg (pl. alert()
vagy felugró custom ablak komponens segítségével).</p>
<p>Ha minden változásnál validálni akarunk, figyelhetjük a
<code>blur</code> eventet is. Ez élesíthet egy validáló metódust, amely
alapján változtathatunk valamilyen adatot, és ennek függvényében
változtathatjuk az input stílusait, vagy megjeleníthetünk figyelmeztető
üzeneteket.</p>
</div>
<div id="saját-inputok-építése" class="section level3">
<h3>Saját inputok építése</h3>
<p>Komponensként létrehozhatunk saját inputokat is, saját html
felépítéssel (pl. gombokból, listből, stb.) és saját stílussal. Ezekben
mindazt felhasználhatjuk, amit a komponensekben használhatunk.</p>
<p>A <code>v-model</code> direktíva ilyen custom input elemeken is
használható. Ez a komponensben létrehoz egy speciális propot
(<code>model-value</code> / <code>modelValue</code>) és egy eventet
(<code>update:modelValue</code>). Ezeket hozzá kell adni a komponens
objektumhoz. A megfelelő metódusban pedig élesíthetjük ezt az eventet,
és további paraméterekként továbbíthatjuk a szükséges adatokat.</p>
<p>A (two-way bindinggal) visszaadott értéket felhasználhatjuk a
stílusokban is (nem kell data property-ként kezelni, pl. hogy melyik az
aktív gomb), vagy használhatunk ezen alapuló computed property-t. (Az
első megoldás egyszerűbb)</p>
<p>Az alábbi példában a li elemhez adott inline stílusokkal jelezzük,
melyik gomb aktív, és ehhez a propként visszaadott modelValue értéket
használjuk közvetlenül. De erre építve computed property-t is
létrehozhatunk (pl. több gomb együttes kijelöléséhez), de ez nem
feltétlenül szükséges.</p>
<p>Az activate metódusban az update:modelValue eventet használjuk, és
továbbítjuk a kiválasztott gombnak megfelelő string értéket, amit a
felhasználó komponensben data property-ként mentünk.</p>
<pre><code>&lt;template&gt;
  &lt;ul&gt;
    &lt;li :class=&quot;{ active: modelValue === &#39;poor&#39; }&quot;&gt;
      &lt;button type=&quot;button&quot; @click=&quot;activate(&#39;poor&#39;)&quot;&gt;Poor&lt;/button&gt;
    &lt;/li&gt;
    &lt;li :class=&quot;{ active: modelValue === &#39;average&#39; }&quot;&gt;
      &lt;button type=&quot;button&quot; @click=&quot;activate(&#39;average&#39;)&quot;&gt;Average&lt;/button&gt;
    &lt;/li&gt;
    &lt;li :class=&quot;{ active: modelValue === &#39;great&#39; }&quot;&gt;
      &lt;button type=&quot;button&quot; @click=&quot;activate(&#39;great&#39;)&quot;&gt;Great&lt;/button&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: [&#39;modelValue&#39;],
  emits: [&#39;update:modelValue&#39;],
  methods: {
    activate(option) {
      this.$emit(&#39;update:modelValue&#39;, option);
    },
  },
};
&lt;/script&gt;</code></pre>
</div>
</div>
<div id="http-requestek" class="section level2">
<h2>Http requestek</h2>
<p>Vue alkalmazásokban is használhatunk http requesteket, amelyek
segítségével az alkalmazásunk egy szerverrel, egy azon futó adatbázissal
tud kommunikálni. Használható a fetch API, vagy külső csomagok (pl.
Axios), és a Promise-ok kezelhetők then/catch-csel és async/await-tel
is.</p>
<p>Figyelni kell a hibák kezelésére (.catch-csel vagy try/catch-csel). A
szerveroldali hibákat jellemzően nem ismeri fel automatikusan a
böngésző, ezért a visszakapott response objektumon ellenőrizni kell az
ok property-t, és szükség esetén új hibát generálni, megfelelő
üzenettel.</p>
<p>Az UI-ban a különböző állapotok kezelésére data property-ket hozunk
létre (pl. isLoading, error), és feltételes rendereléssel jelenítjük meg
a megfelelő komponenseket.</p>
</div>
<div id="routing" class="section level2">
<h2>Routing</h2>
<p>A Vue, akárcsak a React alapvetően single page application-ök (SPA)
készítésére szolgál, mégis, hasznos lehet, ha különböző részekre
különböző url-ek mutatnának, és ezáltal olyan linkeket tudnánk
megosztani, amelyek megnyitása ahhoz a részhez vezet, nem pedig a
főoldalra. Ezt teszi lehetővé a routing.</p>
<p>Ehhez a Vue Router package-et kell telepíteni
<code>npm install vue-router@4</code> (ez a 4-es verziót telepíti).</p>
<div id="router-konfiguráció" class="section level3">
<h3>Router konfiguráció</h3>
<p>Telepítés után importálhatjuk a szükséges függvényeket és
létrehozhatjuk a routert. Ennek megadhatjuk, milyen útvonalakat akarunk
regisztrálni. Ezt a <code>routes</code> property alatt adhatjuk meg. Ez
egy array, amely útvonalanként egy objektumot tartalmaz, amelyek maguk a
path és a component property-kből állnak: pl.
<code>{ path: '/teams', component: TeamsView }</code></p>
<p>A router azt is lehetővé teszi, hogy a böngésző megjegyezze a
meglátogatott url-eket, és a visszalépéssel vissza tudjuk ezekre lépni.
Ehhez a <code>createWebHistory</code> függvényt importálhatjuk és
használhatjuk a router objektum konfigurációja során. Ezt a router
objektum history property-jével adhatjuk meg.</p>
<p>Megj: Régebben erre nem volt lehetőség, és a Vue Routernek emulálnia
kellett a böngészési előzményeket.</p>
<p>Miután létrehoztuk a router objektumot, az alkalmazás objektum
<code>.use</code> metódusával tudjuk ezt összekötni az
alkalmazással.</p>
<pre><code>import { createApp } from &#39;vue&#39;;
import { createRouter, createWebHistory } from &#39;vue-router&#39;;

import App from &#39;./App.vue&#39;;
import TeamsList from &#39;./components/teams/TeamsList.vue&#39;;
import UsersList from &#39;./components/users/UsersList.vue&#39;;

const router = createRouter({
  history: createWebHistory(),
  routes: [
    { path: &#39;/teams&#39;, component: TeamsList },
    { path: &#39;/users&#39;, component: UsersList },
  ],
});

const app = createApp(App);

app.use(router);

app.mount(&#39;#app&#39;);</code></pre>
<p>A routerre való áttéréssel elgondolkodhatunk azon is, hogy egyes
komponenseket, amelyeket bizonyos route-okkal összefüggésben használunk,
áthelyezzük egy külön mappába (pl. <code>pages</code>), és csak azokat a
komponenseket hagyjuk a components mappában, amelyeket beágyazunk.</p>
<p>Sok útvonal esetén szintén jó ötlet lehet a routert külön file-ban
(nem a <code>main.js</code>-ben) létrehozni és
exportálni/importálni.</p>
</div>
<div id="a-route-ok-renderelése-és-navigáció" class="section level3">
<h3>A route-ok renderelése és navigáció</h3>
<p>Miután regisztráltuk a különböző route-okat, ezeket a
<code>&lt;router-view&gt;</code> taggel tudjuk beilleszteni az
alkalmazáson belül. Ezek után, ha a url valamelyik path-nak felel meg, a
tag-en belül az alkalmazás a megadott komponenst rendereli. Pl. a
<code>/users</code> route esetén a UsersList komponens kerül a
<code>router-view</code> elem helyére.</p>
<pre><code>&lt;template&gt;
  &lt;the-navigation @set-page=&quot;setActivePage&quot;&gt;&lt;/the-navigation&gt;
  &lt;main&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/main&gt;
&lt;/template&gt;</code></pre>
<p>A navigáció a <code>&lt;router-link&gt;</code> tag segítségével
történik, amely tartalma bármi (akár html is) lehet, mert a motorháztető
alatt slot-okat használ. Ez utasítja a Vue alkalmazást, hogy a megadott
url-t nyissa meg, és ennek megfelelően renderelje az UI-t. A cél-url-t a
<code>to</code> attribútummal adhatjuk meg. A html-be anchor tag-ek
kerülnek, de automatikusan felülírja a böngésző alapértelmezett
működését, és nem indítják el új oldal betöltését, hanem ugyanazon az
oldalon történik az újrarenderelés.</p>
<p>Ráadásul automatikusan <code>router-link-active</code> és
<code>router-link-exact-active</code> osztályt kapnak az aktív
navigációs elemek, amit a stílusok deklarációjára is felhasználhatunk.
Előbbit akkor is megkapja, ha “al-url”-t nyitunk meg. A router config-ja
segítségével ezeket is megváltoztathatjuk (<code>linkActiveClass</code>
és <code>linkExactActiveClass</code> property-kkel)</p>
<p>JS kódon belül a <code>this.$router</code> metódusaival navigálhatunk
(ehhez azért van hozzáférésünk, mert regisztráltuk a routert az
alkalmazáshoz). A <code>.push()</code> metódus átirányít a megadott
pathra: pl. <code>.push('/users')</code>. A <code>.back()</code> és
<code>.forward()</code> a böngésző vissza- és előrelépés funkcióit
használja.</p>
</div>
<div id="dinamikus-útvonalak" class="section level3">
<h3>Dinamikus útvonalak</h3>
<p>Az Express szintaxisának megfelelően, <code>:</code>-tal dinamikus
részeket is hozzáadhatunk az útvonalakhoz: pl.
<code>'/teams/:teamId'</code> Ha más route-ot is regisztrálni akarunk,
amely <code>/teams/valami</code> formájú, azt ezelőtt kell megadni, mert
különben ezt is felfogja a dinamikus route.</p>
<p>Az útvonalak dinamikus összetevőihez a <code>this.$route</code> révén
férünk hozzá: pl. <code>this.$route.path</code> (teljes útvonal) vagy
<code>this.$route.params</code> (az url-be kódolt paraméterek).</p>
<p>A paraméterek neve azonos azzal, ahogy a router konfigurációjában
megadtuk (pl. teamId), ezek pedig szerepelnek a
<code>this.$route.params</code> objektumon.</p>
<p>A dinamikus útvonalakra való navigálást szintén a router-link elemmel
tudjuk megtenni, a to attribútumot dinamikusan kötve valamilyen JS
kifejezéshez vagy computed property-hez.</p>
<div id="dinamikus-útvonalak-közötti-navigálás" class="section level4">
<h4>Dinamikus útvonalak közötti navigálás</h4>
<p>Probléma lehet, ha azonos felépítésű útvonalak között akarunk
váltani: pl. <code>/teams/t1</code>-ről <code>/teams/t2</code>-re, mivel
ebben az esetben a Vue nem építi újra a UI felületet csak a paraméter
változása miatt.</p>
<p>Erre megoldás lehet, ha létrehozunk egy watchert, amellyel a
<code>$route</code> értéket figyeljük, és amely automatikusan megkapja
paraméterként az új értéket.</p>
</div>
<div id="paraméterek-továbbítása-propként" class="section level4">
<h4>Paraméterek továbbítása propként</h4>
<p>Hasznos lehet, ha a paramétereket nem a route-on keresztül, hanem
propként kapjuk, mert ebben az esetben nem csak routing révén tudjuk
megjeleníteni az adott komponenst, hanem hagyományos módon is.</p>
<p>Ehhez pl. a teamId-t propként adjuk meg, és a
<code>this.$route</code> helyett. Ehhez, hogy routerrel is tovább tudjuk
használni, a megfelelő route regisztrációjánál (pl.
<code>/teams/:teamId</code>) további opcióként hozzáadjuk, hogy
<code>props: true</code>. Ennek hatására a dinamikus komponenseket a
program propként adja át a komponensnek.</p>
<p>Ha mindezt megtesszük, a komponenst a hagyományos módon is
beilleszthetjük, ha megadjuk a szükséges propo(ka)t.</p>
</div>
</div>
<div id="átirányítás" class="section level3">
<h3>Átirányítás</h3>
<p>Egyes route-ok esetében azt szeretnénk, hogy automatikusan
átirányítsunk egy másik route-ra. Ehhez a route konfigurációjánál nem a
renderelendő komponenst adjuk meg, hanem a
<code>redirect: '/path'</code> opciót, ahol megadjuk, milyen útvonalra
szeretnénk átirányítani. Alternatívaként ahhoz a route-hoz, amelyre át
akarunk irányítani is megadhatjuk az <code>alias: '/path'</code>
formában.</p>
<p>A különbség, hogy a redirect-nél a url meg is változik, alias-nél
nem.</p>
</div>
<div id="catch-all-útvonalak" class="section level3">
<h3>Catch all útvonalak</h3>
<p>Minden további útvonal kezelésére (pl. egy 404 oldal
megjelenítésével) létrehozhatunk egy speciális útvonalat, amely path
értéke <code>/:notFound(.*)</code>, ahol a notFound rész más is lehet.
Ehhez is megadhatunk komponenst, vagy redirectet.</p>
</div>
<div id="beágyazott-útvonalak" class="section level3">
<h3>Beágyazott útvonalak</h3>
<p>Az útvonalakat valamely másik útvonal gyermekeként is létrehozhatjuk,
ha valamelyik route-hoz hozzáadjuk a <code>children</code> property-t,
amely értéke egy array, amelybe route-konfigurációk kerülnek
(objektumok). Ezek útvonalából a közös részt kihagyjuk. Pl. ha a
<code>/teams</code> útvonal gyermekeként regisztráljuk a
<code>/teams/:teamId</code> útvonalat, akkor csak <code>:teamId</code>
formában írjuk.</p>
<p>Fontos, hogy az így regisztrált útvonalak nem az App fő file-jában, a
legfelső szinten lesznek elérhetők, hanem abban a komponensben, amelyhez
regisztráltuk őket: pl. a TeamsList komponensben - itt használhatjuk a
<router-view> elemet ezek beillesztésére.</p>
<p>Ez a funkció jól felhasználható, ha az url-től függően más-más
beágyazódó komponenseket szeretnénk megjeleníteni.</p>
</div>
<div id="nevesített-útvonalak" class="section level3">
<h3>Nevesített útvonalak</h3>
<p>A router-linkeknek, .push()-nak, stb. adott útvonalak nemcsak
stringekként adhatók meg, hanem objektum formában is, amelynek path
property-je maga az útvonal string lehet (ezzen túl sokat nem nyerünk),
de megadható másképpen is.</p>
<p>Az utak regisztrációjánál az egyes utaknak nevet is adhatunk a
<code>name</code> property-vel. A <code>to</code>-nak adott objektumban
erre a névre is hivatkozhatunk, és ha paramétert is továbbítani akarunk,
ezt a <code>params</code> property-vel tehetjük meg, amely értéke egy
objektum, ahol a key a megadott név, az érték pedig az értéke.</p>
<p>Ennek előnye, hogy jól olvasható, és könnyen módosítható, ha pl. az
útvonalat megváltoztatjuk, de a nevet nem, akkor a kapcsolatok továbbra
is működnek.</p>
<pre><code>&lt;template&gt;
  &lt;li&gt;
    &lt;h3&gt;{{ name }}&lt;/h3&gt;
    &lt;div class=&quot;team-members&quot;&gt;{{ memberCount }} Members&lt;/div&gt;
    &lt;router-link :to=&quot;teamMembersLink&quot;&gt;View Members&lt;/router-link&gt;
  &lt;/li&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: [&#39;id&#39;, &#39;name&#39;, &#39;memberCount&#39;],
  computed: {
    teamMembersLink() {
      return { name: &#39;team-members&#39;, params: { teamId: this.id } };
    },
  },
};
&lt;/script&gt;</code></pre>
</div>
<div id="query-paraméterek" class="section level3">
<h3>Query paraméterek</h3>
<p>A fenti módon (természetesen stringként megadva is) könnyen
hozzáadhatók query paraméterek is, a <code>query</code> property-vel,
amely értéke szintén egy objektum, amelyben a key-value párok adják meg
a query paramétereket: pl. <code>{ sort: 'asc' }</code></p>
<p>Ezeket felhasználhatjuk a renderelés során: a hozzáférés a
<code>this.$route.query</code> property révén történik. Props-ként nem
adhatók meg. Ezek viszont opcionálisak, az útvonalak ezek nélkül is
működnek, ezért nem lehetetlenítik el a komponens más módon való
beillesztését, de ebben az esetben nem lesz ezekhez hozzáférésünk.</p>
</div>
<div id="több-router-view-ugyanazon-a-szinten" class="section level3">
<h3>Több router-view ugyanazon a szinten</h3>
<p>Ha egy útvonalon több komponenst szeretnénk renderelni, előfordulhat,
hogy több router-view elemet illesztünk be.</p>
<p>Ehhez az útvonal konfigurációjában a <code>component</code> helyett a
<code>components</code> property-t is haszálhatjuk, amelyhez egy
objektumot rendelünk, ahol a key megadja, melyik router-view-höz
szeretnénk rendelni, az érték pedig megadja, melyik komponenst. Ehhez a
router-view-ket elnevezzük. Legfeljebb egy router-view maradhat
névtelen, ez lesz a default.</p>
<p>Ettől függetlenül lehetnek olyan útvonalaink, ahol csak egy
komponenst renderelünk: ez a default router-view-be megy.</p>
</div>
<div id="navigation-guards" class="section level3">
<h3>Navigation Guards</h3>
<p>Lehetővé teszik, hogy navigáció során ellenőrizzük pl. a
jogosultságot, illetve megakadályozzuk, hogy a felhasználó ellépjen egy
félig kitöltött formról az adatok mentése, elküldése nélkül.</p>
<p>Global .beforeEach(), ha a router objektumhoz adjuk
`router.beforeEach()`` - to, from és next - függvény, alapból true
(engedi a továbblépést), ha false, nem engedi, ha pathnév (string) vagy
path objektum (nevesített, paraméterekkel, stb.) akkor oda visz
tovább.</p>
<p>Regisztrált útvonalakhoz is megadhatunk ilyeneket: az útvonal
konfigurációjába a beforeEnter() metódust illesztve - ugyanazokat a
paramétereket kapja.</p>
<p>Komponensekben is hozzáadható a beforeRouteEntered() metódus.</p>
<p>Először a globális fut le, aztán az útvonalhoz regisztrált guard,
végül a komponensben deklarált guard.</p>
<p>Ha olyan komponenssel dolgozunk, amelyet nem újraépít, csak frissít
új adatokkal, a beforeRouteUpdate() metódust használhatjuk. Ez csak
akkor fut le, ha routinggal összefüggésben frissül, ezért szűkítheti a
komponens felhasználhatóságát, de ha ez nem gond, alternatívája lehet a
watcher beállításnak, hogy frissüljön a komponens.</p>
<p>A globális .afterEach() csak to és from argumentumot kap. Használható
pl. analitika küldésére. Ahhoz már késő, hogy azt befolyásoljuk, mit lát
a felhasználó, mert ez a navigáció elfogadása után történik csak.</p>
<p>Az unmounted() életciklus-metódussal megadhatunk olyan parancsokat,
amelyeket azelőtt futtatunk, hogy a felhasználó elhagyna egy komponenst.
Ez viszont azután fut, hogy már elhagytuk az oldalt. Vannak viszont
esetek, amikor meg akarjuk akadályozni az elnavigálást (pl. mentetlen
változások miatt).</p>
<p>Szintén a komponensben megadhatjuk a <code>beforeRouteLeave()</code>
metódust, ha routert használunk. Ez is to, from, next argumentumokat
kap. Ebben például megerősítést kérhetünk a confirm paranccsal, amely
eredményét változóba mentve felhasználhatjuk, hogy a next lefutása ennek
értékétől függjön.</p>
</div>
<div id="route-metaadatok" class="section level3">
<h3>Route metaadatok</h3>
<p>Az egyes regisztrált útvonalakhoz metaadatokat is megadhatunk a
<code>meta</code> property-vel, amelynek értéke pl. egy objektum lehet,
amelyben megadhatunk ilyen saját készítésű metaadatokt (pl.
<code>needsAuth: true</code>). Ezeket a metaadatokat elérjük a
komponensekben, ahol hozzáférünk a <code>$route</code> objektumhoz, de a
navigáció során a <code>from</code> és <code>to</code> objektumokon is.
Így a globális navigation guardokat is tudjuk szelektíven, csak néhány
útvonal esetében élesíteni.</p>
</div>
<div id="scrollbehavior" class="section level3">
<h3>scrollBehavior</h3>
<p>Ilyen a scrollBehavior, ami egy metódusként adható a router
setupjához. Három argumentumot kap: <code>to</code>, <code>from</code>,
<code>savedPosition</code>. A to és a from két útvonal objektum: ahonnan
és ahová navigálunk. A savedPosition a scroll pozíciót tartalmazza,
ahonnan érkeztünk: left és top property-kből álló objektumként. A
metódus return értéke egy objektum legyen left és top property-kkel,
amelyek megadják, hová ugorjon az új oldal megnyitásakor: pl.
<code>{ left: 0, top: 0 }</code> hatására mindig az oldal tetejére
ugrik. A savedPosition argumentum felhasználható, hogy visszalépésnél
ugyanoda ugorjon, ahol volt.</p>
</div>
</div>
<div id="stílusok-hozzáadása" class="section level2">
<h2>Stílusok hozzáadása</h2>
<p>CSS stílusokat többféleképpen adhatunk hozzá. A legegyszerűbb az
inline stílusok használata, amihez ugyancsak használhatunk változókat. A
<code>style</code> property nemcsak striget, hanem objektumot is
elfogad, amelyben a kulcsok a css property-k camelCase formában vagy
kebab-case formában, az értékek pedig JS kifejezések, amelyek érvényes
string értékeket adnak.</p>
<pre><code>&lt;div class=&quot;demo&quot; :style=&quot;{borderColor: boxASelected ? &#39;red&#39; : &#39;#ccc&#39;}&quot; @click=&quot;boxSelected(&#39;A&#39;)&quot;&gt;&lt;/div&gt;</code></pre>
<p>Jobb megoldás azonban a dinamikus stílusok használata, aminek több
módja van. A <code>class</code> property elfogad egy array-t a
hozzáadandó class-okkal (ebben is lehetnek számított változók is), egy
objektumot, amelynek kulcsai a class-nevek, értékei pedig boolean
értékeket adó JS kifejezések, de megadhatók a class-ok több részletben
is.</p>
<pre><code>&lt;div :class=&quot;{demo: true, active: boxBSelected}&quot; @click=&quot;boxSelected(&#39;B&#39;)&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[&#39;demo&#39;, boxCClasses]&quot; @click=&quot;boxSelected(&#39;C&#39;)&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;demo&quot; :class=&quot;{active: boxDSelected}&quot; @click=&quot;boxSelected(&#39;D&#39;)&quot;&gt;&lt;/div&gt;</code></pre>
<p>Végül komplex alkalmazásoknál a stílusdeklarációk a vue file-ok
részei is lehetnek. EZek azonban továbbra is az egész alkalmazásra
vonatkoznak. Ezt megváltoztathatjuk, hogy a nyitó
<code>&lt;style&gt;</code> tagbe a <code>scoped</code> attribútumot
írjuk: <code>&lt;style scoped&gt;</code></p>
<p>Ennek hatására a Vue speciális attribútumokat ad a html elemekhez, és
a css file-ban ezeket felhasználja: attribútumokkal kiegészített
selectorokat használ.</p>
</div>
<div id="vue-alkalmazások-életciklusa" class="section level2">
<h2>Vue alkalmazások életciklusa</h2>
<p>beforeCreate() - pl. http requestet küldhetünk created()
beforeMount() mounted() beforeUpdate() updated() beforeUnmount()
unmounted()</p>
<p>Ezeket metódusként adhatjuk hozzá a createApp objektumához, a data,
methods, stb. mellett, tehát NEM a methods objektumon belül. A valóságan
ezeknek csak egy kisebb részhalmazát használjuk. A metódusokon belül
olyan parancsokat adhatunk meg, amelyeket csak az adott életciklus
esemény bekövetkezésekor futtat az alkalmazás.</p>
</div>
<div id="animáció-és-tranzíció" class="section level2">
<h2>Animáció és tranzíció</h2>
<p>Elemek animálása legkönnyebben speciális class-ok segítségével
történhet, amelyek feltételes hozzáadásával elindíthatjuk az animációt.
A megjelenő elemek animációja nem probléma, az eltűnőeké viszont már nem
oldható meg simán css-szel.</p>
<p>A Vue tartalmaz egy <code>&lt;transition&gt;</code> tag-et, amely egy
közvetlen gyermeket tartalmazhat, amellyel animálhatjuk a
belépést/kilépést. Ez a tag speciális css osztályokat hoz létre, és
ezeket adott sorrendben hozzáadja, majd törli, hogy az animációt
végrehajtsák. A Vue emellett biztosítja, hogy a komponens csak azután
semmisül meg, hogy az animáció lefutott. Ezt feltételesen renderelt
komponensekhez használjuk, hiszen a folyamatosan jelenlévő komponenseket
osztályok hozzáadásával és törlésével tudjuk animálni.</p>
<p>A létrehozott osztályok:</p>
<ul>
<li>v.enter-from: kiinduló helyzet</li>
<li>v.enter-active: ide kerülhet pl. a transition property</li>
<li>v.enter-to: végállapot</li>
<li>v.leave-from: kezdőállapot</li>
<li>v.leave-active: a folyamatot szabályozza</li>
<li>v.leave-to: végállapot</li>
</ul>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
