<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>React</title>

<script src="site_libs/header-attrs-2.24/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #a0a0a0;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
div.sourceCode
  { color: #1f1c1b; background-color: #ffffff; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { color: #1f1c1b; } /* Normal */
code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
code span.an { color: #ca60ca; } /* Annotation */
code span.at { color: #0057ae; } /* Attribute */
code span.bn { color: #b08000; } /* BaseN */
code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #924c9d; } /* Char */
code span.cn { color: #aa5500; } /* Constant */
code span.co { color: #898887; } /* Comment */
code span.cv { color: #0095ff; } /* CommentVar */
code span.do { color: #607880; } /* Documentation */
code span.dt { color: #0057ae; } /* DataType */
code span.dv { color: #b08000; } /* DecVal */
code span.er { color: #bf0303; text-decoration: underline; } /* Error */
code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #644a9b; } /* Function */
code span.im { color: #ff5500; } /* Import */
code span.in { color: #b08000; } /* Information */
code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code span.op { color: #1f1c1b; } /* Operator */
code span.ot { color: #006e28; } /* Other */
code span.pp { color: #006e28; } /* Preprocessor */
code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #ff5500; } /* SpecialString */
code span.st { color: #bf0303; } /* String */
code span.va { color: #0057ae; } /* Variable */
code span.vs { color: #bf0303; } /* VerbatimString */
code span.wa { color: #bf0303; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>







<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Programozás jegyzeteim</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Vanilla JS
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="vanilla/js-variables.html">JavaScript alapok</a>
    </li>
    <li>
      <a href="vanilla/js-program-flow.html">Program Flow Control</a>
    </li>
    <li>
      <a href="vanilla/js-functions.html">Függvények</a>
    </li>
    <li>
      <a href="vanilla/js-data-structures.html">Adatstruktúrák</a>
    </li>
    <li>
      <a href="vanilla/js-array-methods.html">Haladó Array műveletek</a>
    </li>
    <li>
      <a href="vanilla/js-dom-manipulation.html">DOM manipuláció</a>
    </li>
    <li>
      <a href="vanilla/js-strings.html">Stringek</a>
    </li>
    <li>
      <a href="vanilla/js-numbers-dates.html">Számok és dátumok</a>
    </li>
    <li>
      <a href="vanilla/js-regex.html">Reguláris kifejezések</a>
    </li>
    <li>
      <a href="vanilla/js-async.html">Asynchronous JavaScript</a>
    </li>
    <li>
      <a href="vanilla/js-oop.html">OOP</a>
    </li>
    <li>
      <a href="vanilla/js-dev-practice.html">JavaScript Development a gyakorlatban</a>
    </li>
    <li>
      <a href="vanilla/js-api.html">Hasznos API-k</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Typescript
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="ts-basics.html">TypeScript basics</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Front-End JS Libraries&amp;Frameworks
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="front-end/jquery-basics.html">jQuery</a>
    </li>
    <li>
      <a href="front-end/react-basics.html">React</a>
    </li>
    <li>
      <a href="front-end/redux-basics.html">Redux</a>
    </li>
    <li>
      <a href="front-end/next.html">Next</a>
    </li>
    <li>
      <a href="front-end/vue-basics.html">Vue.js</a>
    </li>
    <li>
      <a href="front-end/angular.html">Angular</a>
    </li>
    <li>
      <a href="front-end/svelte.html">Svelte</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Back-End JS
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="back-end/node-js.html">Node.js</a>
    </li>
    <li>
      <a href="back-end/express-js.html">Express.js</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Miscellaneous
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="misc/js-libraries.html">JS libraries</a>
    </li>
    <li>
      <a href="misc/js-testing.html">JS Testing</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">React</h1>

</div>


<p>A React ötvözi a HTML és a JavaScript előnyeit: HTML-t írhatunk
kiegészítve JS programkódokkal. A Reactot a Facebook hozta létre és
tette nyilvánosan elérhetővé, és ők is tartják karban és fejlesztik.
Különösen hasznos nagy front-end applikációk esetében, ahol sok
komponensből álló alkalmazásokat kezelünk. A React egyszerűsíti a
komplex kód kezelését, hiszen támogatja a moduláris felépítést, és
gyorsabb is, mivel Virtuális DOM-ot használ, és így a honlapnak csak
azokat a részeit frissíti (előbb a virtuális DOM reprezentációban),
amelyek ténylegesen változtak. Ezután a VDOM-ot összeveti az előző
állapottal, és csak azokat a DOM frissítéseket hajtja végre, amelyek
ahhoz szükségesek, hogy a kívánt állapotba hozza a DOM-ot.</p>
<p>A React az ún. JavaScript eXtended Syntax-t használja (JSX), amely
lehetővé teszi, hogy html elemeket hozzunk létre közvetlenül a JS kód
részeként, nem pedig stringként (vs. hagyományos DOM manipuláció).</p>
<p>A React nagy újdonságai:</p>
<ul>
<li><strong>Deklaratív megközelítés</strong>: a <code>state</code>
segítségével nem közvetlenül módosítjuk az oldal részeit a felhasználó
különböző tevékenységei hatására, hanem az állapot függvényében adjuk
meg, egy-egy komponens hogyan viselkedjen.</li>
<li><strong>Komponensalapú felépítés</strong>: a React alkalmazások
potenciálisan újrafelhasználható komponensekből épülnek fel, amelyek
külön fejleszthetők, egymásba ágyazódhatnak, kommunikálhatnak egymással.
Erre egész komponens-könyvtárak épültek fel (mui, react-bootstrap,
stb.)</li>
<li><strong>Egyirányú adatfolyam</strong>: ha változást szeretnénk az
alkalmazásban, akkor az alkalmazás állapotát (state) kell változtatnunk.
A React erre reagálva újraalkotja a szükséges komponenseket. Az adatok
mindig csak lefelé tudnak vándorolni a virtuális DOM-on.</li>
<li><strong>UI könyvtár</strong>: ellentétben pl. az Angular-ral, a
React.js csak a komponensekkel, virtuális DOM-mal foglalkozik, csak a
<code>view</code> részt kezeli, a továbbiakra külön könyvtárakat
használhatunk, amelyeket viszonylag szabadon választhatunk meg. Így
jöhetett létre a React Native, amely mobil-alkalmazásokat kezel, a React
360, amely VR alkalmazásokat tud kezelni, Electron és React Desktop
számítógépes alkalmazásokat tud kezelni, stb.</li>
</ul>
<div id="react-hozzáadása" class="section level2">
<h2>React hozzáadása</h2>
<div id="egyszerű-projekt" class="section level3">
<h3>Egyszerű projekt</h3>
<p>A React használatához az alábbi script tageket kell a honlapunk
html-jébe illeszteni:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="kw">&lt;script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span> <span class="er">crossorigin</span><span class="kw">&gt;&lt;/script&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="kw">&lt;script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span> <span class="er">crossorigin</span><span class="kw">&gt;&lt;/script&gt;</span> </span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="kw">&lt;script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span> </span></code></pre></div>
<p>Ez a fajta hozzáadás kis demok létrehozásához megfelelő.</p>
<p>A React scriptet ezután például egy script tagbe írhatjuk:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="kw">&lt;script</span><span class="ot"> type=</span><span class="st">&quot;text/babel&quot;</span><span class="kw">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="kw">&lt;/script&gt;</span></span></code></pre></div>
</div>
<div id="komplex-projektek" class="section level3">
<h3>Komplex projektek</h3>
<p>Komolyabb projektekhez Node.js szükséges. A Facebook létrehozta a
<code>Create React App</code> eszközt. Az alábbi terminál script
létrehozza a “my-app” nevű React alkalmazást és telepíti az összes
szükséges könyvtárat, majd elindítja a projektet a localhost 3000-es
portján.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="ex">npx</span> create-react-app my-app</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="bu">cd</span> my-app</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="ex">npm</span> start</span></code></pre></div>
<p><strong>Projekt struktúra:</strong></p>
<p>A fenti parancs egy projektstruktúrát hoz létre. A public mappában a
projekt megjelenéséhez kapcsolódó file-ok kapnak helyet (pl.
index.html), az src mappa tartalmazza az összes JS, CSS kódot, képeket.
Mindezeket egy <em>file loader</em> csomagolja egybe egyetlen html
file-be: a React a Webpack-ot használja.</p>
<p>A legfontosabb file-ok: A fő html file az public/index.html. A React
kódot a src könyvtár src/index.js file-jába írhatjuk (ez az
<code>entry point</code>). A fő CSS file a src/style.css A projekt
metaadatait (pl. szükséges kiegészítő csomagokat) a src/package.json
tartalmazza. Ha másik gépen szeretnénk dolgozni a projekten, ez a file
lehetővé teszi a szükséges csomagok telepítését
(<code>npm install</code>)</p>
</div>
</div>
<div id="html-elemek-létrehozása-és-renderelése-jsx"
class="section level2">
<h2>HTML elemek létrehozása és renderelése: JSX</h2>
Lehetőség van JS változóként elmenteni HTML elementeket. A lényeg, hogy
csak egy elemet menthetünk, ezért a komplexebb, többelemű HTML-t egy
<div>
<p>-be, vagy másba kell “csomagolni”. Ez lehet egy ún.
<code>fragment</code> is: <code>&lt;&gt;</code> és
<code>&lt;/&gt;</code>, vagy ha ez nem működik (project setuptól függ,
de create-react-app-nál működik) <code>&lt;React.Fragment&gt;</code> és
<code>&lt;/React.Fragment&gt;</code> közé (nevesített importnál simán
<code>&lt;Fragment&gt;</code> is használható).</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="kw">const</span> JSX <span class="op">= </span><span class="kw">&lt;div&gt;&lt;/div&gt;</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="kw">const</span> complexJSX <span class="op">= </span><span class="kw">&lt;div&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>    <span class="kw">&lt;h1&gt;</span>Heading<span class="kw">&lt;/h1&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>    <span class="kw">&lt;p&gt;</span>Lorem ipsum dolor sit amet<span class="kw">&lt;/p&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>  <span class="kw">&lt;/div&gt;</span><span class="op">;</span></span></code></pre></div>
<p>Ha JavaScript kódot akarunk hozzáadni a JSX-hez, akkor azt {} közé
kell írni. Pl. kommentet a következőképpen tudunk írni:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>{<span class="co">/* Comment */</span>}</span></code></pre></div>
<p>Változókat is használhatunk a html elemek létrehozásában.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="kw">const</span> name <span class="op">=</span> <span class="st">&quot;David&quot;</span><span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="kw">const</span> el <span class="op">= </span><span class="kw">&lt;p&gt;</span>Hello, <span class="va">{</span>name<span class="va">}</span><span class="kw">&lt;/p&gt;</span><span class="op">;</span></span></code></pre></div>
<p>Az elemekhez adhatunk <code>id</code>-t és <code>class</code>-t is.
Ehhez is használhatunk változókat. Ha az elemnek <code>class</code>-t is
akarunk adni, akkor viszont a szokásos <code>class</code> helyett
(JS-ben foglalt) a <code>className</code>-et kell használni. Ehhez
hasonlóan Reactban több HTML attribútum camelCase formájú.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="kw">const</span> JSX <span class="op">= </span><span class="kw">&lt;div</span> <span class="ot">id</span><span class="op">=</span><span class="st">&quot;my-id&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="kw">const</span> JSX <span class="op">= </span><span class="kw">&lt;div</span> <span class="ot">id</span><span class="op">=</span><span class="va">{</span>userId<span class="va">}</span><span class="kw">&gt;&lt;/div&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="kw">const</span> JSX <span class="op">= </span><span class="kw">&lt;div</span> <span class="ot">className</span><span class="op">=</span><span class="st">&quot;my-div&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></span></code></pre></div>
<p>A React tag-ek lehetnek önmagukat zárók, ha üresek. Viszont az üres
tag-eket is le kell zárni kötelezően.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="kw">const</span> JSX <span class="op">= </span><span class="kw">&lt;div&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>    <span class="kw">&lt;p&gt;</span>Lorem ipsum<span class="kw">&lt;/p&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    <span class="kw">&lt;br</span> <span class="kw">/&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    <span class="kw">&lt;hr</span> <span class="kw">/&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>    <span class="kw">&lt;div</span> <span class="kw">/&gt;</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>  <span class="kw">&lt;/div&gt;</span></span></code></pre></div>
<div id="js-kód-és-jsx" class="section level3">
<h3>JS kód és JSX</h3>
<p>A JSX mellett hagyományos JS kódot is használhatunk. Utóbbit csak
akkor kell <code>{}</code> közé tenni, ha a JSX részben használjuk (pl.
a return érték részeként), egyébként nem. A class komponensek render
metódusában például anélkül használhatunk JS kódot. A return részben
viszont már JSX-ról van szó, ezért használni kell a kapcsos
záróljeleket!</p>
<p>A JS kód gyakori alkalmazása például, hogy valamilyen feltétel
alapján rendereljük bizonyos módokon a komponenseket. A feltétel
függvényében változhat, hogy melyik komponenst rendereljük, annak részei
megjelennek-e, illetve a css formázás is. Ez történhet if/else-zel,
ternary operatorral vagy rövidre zárással is. A zárójelezésre a fenti
szabályok vonatkoznak.</p>
</div>
<div id="react-portal" class="section level3">
<h3>React Portal</h3>
<p>A tiszta html struktúrához néha az kell, hogy az együtt, pl. egy
fragmentumban renderelt elemek ne egymás mellé kerüljenek, hanem az
egyik elem a DOM tetejére (pl. modális ablak ne az oldal közepén
legyen). Működőképes lehet az alkalmazás máshogy is, de szemantikai
szempontból nem optimális megoldás.</p>
<p>Alapesetben a komponensek és elemek oda renderelődnek, ahol a JSX-ben
szerepelnek. Tisztább és jobb megoldás a portál.</p>
<p>A html-ben létrehozhatunk olyan diveket, amelyekbe az új elemek
kerülnek: a <code>root</code> mellett lesz pl. egy
<code>modal-root</code>. Ezek után a renderelés a ReactDOM
<code>.createPortal</code> metódusával történik, a returnben a
renderelendő JSX kódot a <code>.createPortal</code> metódusba
csomagoljuk. A metódus első paramétere a komponens, amelyet renderelni
akarunk (beleértve az összes szükséges props-ot), a második paraméter
pedig a DOM-nak az az eleme, amelyhez adni szeretnénk.</p>
<pre><code>ReactDOM.createPortal(&lt;ErrorModal title={props.title} message={props.message} onConfirm={props.onConfirm} /&gt;, document.getElementById(&quot;modal-root&quot;));</code></pre>
<p>A portállal áthelyezett elemeknek a DOM-beli helye változik,
ugyanakkor ugyanúgy működnek, mint a sima React elemek, vagyis ugyanúgy
hozzáférnek a megfelelő változókhoz, mintha a JSX-ben megadott helyen
renderelnénk őket.</p>
</div>
</div>
<div id="komponensek" class="section level2">
<h2>Komponensek</h2>
<p>A React magját a komponensek adják, amelyek az oldalt független és
újra felhasználható elemekre bontják. Ez lehet egy fejléc, cím, input
mező, lista és annak elemei, gombok, stb. Kétféleképpen hozhatók létre:
függvénnyel vagy class-ként.</p>
<div id="létrehozás" class="section level3">
<h3>Létrehozás</h3>
<p><strong>Függvény komponensek:</strong></p>
<p>Ebben az esetben <code>stateless functional component</code>-ről
beszélünk. Ehhez egy olyan JS függvényt kell írni, amely return értéke
egy JSX vagy <code>null</code>. A függvény nevének
<strong>nagybetűvel</strong> kell kezdődnie!</p>
<p><em>Megjegyzés: Arrow függvény is használható.</em></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="kw">const</span> MyComponent <span class="op">=</span> <span class="kw">function</span>() {</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>    <span class="kw">&lt;div&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>      <span class="kw">&lt;p&gt;</span>Lorem ipsum<span class="kw">&lt;/p&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>    <span class="kw">&lt;/div&gt;</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>  )</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>}</span></code></pre></div>
<p>Mostanában, mióta a hookok révén lehetővé vált a state kezelése, ezek
népszerűbbek.</p>
<p><strong>ES6 Class-ként:</strong></p>
<p>Ha class-ként hozzuk létre, akkor a React.Component class-t kell
kiterjeszteni, hogy hozzáférést kapjon annak metódusaihoz. Az új
komponensnek tartalmaznia kell a render metódust. A constructor függvény
használata javasolt (FCC), de ha jól értem, nem kötelező (sololearn). Ha
azt szeretnénk, hogy a komponensünknek legyen state-je, ezt a
constructorban tudjuk létrehozni az instanciálás során.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="kw">class</span> MyComponent <span class="kw">extends</span> React<span class="op">.</span><span class="at">Component</span> {</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  <span class="fu">constructor</span>(props) {</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>    <span class="kw">super</span>(props)<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  }</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>  <span class="fu">render</span>() {</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>    <span class="cf">return</span> (</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>      <span class="kw">&lt;div&gt;</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>        <span class="kw">&lt;h1&gt;</span>Hello React!<span class="kw">&lt;/h1&gt;</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>      <span class="kw">&lt;/div&gt;</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>    )</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>  }</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
</div>
<div id="használat" class="section level3">
<h3>Használat</h3>
<p>Ezt követően a komponenseket beilleszthetjük, változóba menthetjük,
stb. Ennek módja, hogy mintha üres html tag-eket adnánk hozzá (/&gt;-vel
lezárjuk), de ezek neve a komponensnév. Lehetőség van konténer
komponenseket is létrehozni, amelyek nyitó és záró-tagje közé tartalmat
illeszthetünk. Ezt az adott komponens <code>props</code>-ként
megkapja.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="kw">const</span> el <span class="op">= </span><span class="fu">&lt;MyComponent</span> <span class="fu">/&gt;</span></span></code></pre></div>
<p>Jó gyakorlat külön .js file-okat létrehozni az egyes komponenseknek,
és ezeket a modulokat importálni azokba a komponens-file-okba, amelyek
használják ezeket:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="im">import</span> Button <span class="im">from</span> <span class="st">&#39;./UI/Button&#39;</span><span class="op">;</span></span></code></pre></div>
<p>Minden file-ban exportáljuk a létrehozott komponenst, default
exportként. Ezt érdemes a file végén megtenni, mert így használhatjuk a
typeChecking és defaultProps funkciókat. A más file-ban definiált, de az
adott komponens által felhasznált alkomponenseket a file elején
importáljuk.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> ComponentName<span class="op">;</span></span></code></pre></div>
<p><strong>Egymásba ágyazódó komponensek</strong></p>
<p>Az új komponensek használhatnak korábban létrehozott komponenseket.
Jó gyakorlat a komplex komponenseket elemi komponensekre bontani,
amelyek újrahasznosíthatók.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="kw">function</span> <span class="fu">App</span>() {</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>  <span class="cf">return </span><span class="kw">&lt;div&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>    <span class="fu">&lt;NewUser</span> <span class="fu">/&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>    <span class="fu">&lt;UsersList</span> <span class="fu">/&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>    <span class="fu">&lt;Footer</span> <span class="fu">/&gt;</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>  <span class="kw">&lt;/div&gt;</span><span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="elemek-programatikus-renderelése" class="section level3">
<h3>Elemek programatikus renderelése</h3>
Kihasználva a JS képességeit, lehetőség van array-ből listaelemeket,
divek sorozatát, stb. renderelni (pl. map függvény, ahol a return érték
egy-egy
<li>
elem lesz), amelyeket
<ul>
{listItems}
</ul>
formában renderelünk, ahol listItems az
<li>
<p>elemek array-e.</p>
<p>Az array elemeit propsként adhatjuk meg <ListName data={array} />
formában.</p>
<p>Ez a lehetőség különösen hasznos, ha nem tudjuk előre, hány elemet
kell renderelni, mert az a felhasználó inputjától függ.</p>
<p>Arra kell viszont figyelni, hogy Reactban (és Vue-ban is) minden
listaelemnek egyedi azonosítóval (<code>key</code>) kell rendelkeznie.
Ez jöhet úgy, hogy az eredeti array elemei objektumok (id - név párok),
vagy úgy, hogy az indexet vagy egy random számot használunk egyedi
kulcsként.</p>
<p>Ez a kulcs ahhoz kell, hogy a React azonosítani tudja az adott
elemet, például, ha törölni akarjuk, ez alapján tudja, mely elemet
törölje. Az azonosítható elemek esetében kevesebb az újrarenderelés is,
mert csak a ténylegesen változó elemeket kell újrarenderelni.</p>
</div>
</div>
<div id="dom-hoz-adás" class="section level2">
<h2>DOM-hoz adás</h2>
<p>A DOM-hoz adás a <code>ReactDom.render()</code> függvénnyel történik.
A <code>targetNode</code> megadható a
<code>document.getElementById()</code> vagy
<code>document.querySelector()</code> révén is, közvetlenül a
<code>render()</code>-ben. A render felülírja a tartalmat, ezért a
konténerek jellemzően üresek a html-ben. Egy React program jellemzően
egyszer használja a render parancsot.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>ReactDOM<span class="op">.</span><span class="fu">render</span>(component<span class="op">,</span> targetNode)</span></code></pre></div>
<p>A későbbiekben viszont már nem újrarenderelésről, nem is közvetlen
DOM manipulációról van szó, hanem az alkalmazás állapotának
változtatásával tudjuk elérni, hogy a megjelenített komponensek
változzanak.</p>
</div>
<div id="komponens-kommunikáció-props" class="section level2">
<h2>Komponens kommunikáció: Props</h2>
<p>A komponensek létrehozásában használhatunk <code>props</code>-okat
(argumentumokat), amelyeket ezek megkapnak a renderelés során. Ezek egy
objektumban találhatók. Propból több is lehet a <code>props</code>
objektum részeként.</p>
<p><em>Mint minden objektum, a props is destrukturálható, és ebben az
esetben nem kell a props.propertyName a hozzáféréshez.</em></p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="kw">const</span> MyComponent <span class="op">=</span> <span class="kw">function</span>(props) {</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>  <span class="cf">return </span><span class="kw">&lt;p&gt;</span>Hello, <span class="va">{</span>props<span class="op">.</span><span class="at">name</span><span class="va">}</span>!<span class="kw">&lt;/p&gt;</span><span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>}</span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="kw">const</span> el <span class="op">= </span><span class="fu">&lt;MyComponent</span> <span class="ot">name</span><span class="op">=</span><span class="st">&quot;John&quot;</span> <span class="fu">/&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a><span class="kw">class</span> Hello <span class="kw">extends</span> React<span class="op">.</span><span class="at">Component</span> {</span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>  <span class="fu">render</span>() {</span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a>    <span class="cf">return </span><span class="kw">&lt;p&gt;</span>Hello, <span class="va">{</span><span class="kw">this</span><span class="op">.</span><span class="at">props</span><span class="op">.</span><span class="at">name</span><span class="va">}</span>!<span class="kw">&lt;/p&gt;</span><span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a>  }</span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a>} </span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a><span class="kw">function</span> <span class="fu">Item</span>(props) {</span>
<span id="cb17-14"><a href="#cb17-14" tabindex="-1"></a>  <span class="cf">return </span><span class="kw">&lt;div</span> <span class="ot">className</span><span class="op">=</span><span class="st">&quot;item&quot;</span><span class="kw">&gt;</span></span>
<span id="cb17-15"><a href="#cb17-15" tabindex="-1"></a>  <span class="kw">&lt;b&gt;</span>Name:<span class="kw">&lt;/b&gt;</span> <span class="va">{</span>props<span class="op">.</span><span class="at">name</span><span class="va">}</span> <span class="kw">&lt;br</span> <span class="kw">/&gt;</span></span>
<span id="cb17-16"><a href="#cb17-16" tabindex="-1"></a>  <span class="kw">&lt;b&gt;</span>Price:<span class="kw">&lt;/b&gt;</span> <span class="va">{</span>props<span class="op">.</span><span class="at">price</span><span class="va">}</span></span>
<span id="cb17-17"><a href="#cb17-17" tabindex="-1"></a>  <span class="kw">&lt;/div&gt;</span><span class="op">;</span></span>
<span id="cb17-18"><a href="#cb17-18" tabindex="-1"></a>}</span>
<span id="cb17-19"><a href="#cb17-19" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" tabindex="-1"></a><span class="fu">&lt;Item</span> <span class="ot">name</span><span class="op">=</span><span class="st">&quot;Cheese&quot;</span> <span class="ot">price</span><span class="op">=</span><span class="st">&quot;4.99&quot;</span> <span class="fu">/&gt;</span> </span>
<span id="cb17-21"><a href="#cb17-21" tabindex="-1"></a><span class="fu">&lt;Item</span> <span class="ot">name</span><span class="op">=</span><span class="st">&quot;Bread&quot;</span> <span class="ot">price</span><span class="op">=</span><span class="st">&quot;1.5&quot;</span> <span class="fu">/&gt;</span></span>
<span id="cb17-22"><a href="#cb17-22" tabindex="-1"></a><span class="fu">&lt;Item</span> <span class="ot">name</span><span class="op">=</span><span class="st">&quot;Ice cream&quot;</span> <span class="ot">price</span><span class="op">=</span><span class="st">&quot;24&quot;</span> <span class="fu">/&gt;</span></span></code></pre></div>
<p>Ha a megadott prop érték nem string, hanem szám, array vagy
változónév <code>{}</code> közé kell tenni, hogy JS kódként kezelje:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">&lt;ParentComponent&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>  <span class="fu">&lt;ChildComponent</span> <span class="ot">colors</span><span class="op">=</span><span class="va">{</span>[<span class="st">&quot;green&quot;</span><span class="op">,</span> <span class="st">&quot;blue&quot;</span><span class="op">,</span> <span class="st">&quot;red&quot;</span>]<span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>  <span class="fu">&lt;ChildComponent2</span> <span class="ot">quantity</span><span class="op">=</span><span class="va">{</span><span class="dv">3</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="fu">&lt;/ParentComponent&gt;</span></span></code></pre></div>
<p>Több propsot egyszerre megadhatunk úgy is, hogy egy objektumban
helyezzük el ezeket, és a spread operátorral adjuk a komponenshez.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="kw">const</span> Input <span class="op">=</span> (props) <span class="kw">=&gt;</span> {</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>    <span class="kw">&lt;div</span> <span class="ot">className</span><span class="op">=</span><span class="va">{</span>classes<span class="op">.</span><span class="at">input</span><span class="va">}</span><span class="kw">&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>      <span class="kw">&lt;label</span> <span class="ot">htmlFor</span><span class="op">=</span><span class="va">{</span>props<span class="op">.</span><span class="at">input</span><span class="op">.</span><span class="at">id</span><span class="va">}</span><span class="kw">&gt;</span><span class="va">{</span>props<span class="op">.</span><span class="at">label</span><span class="va">}</span><span class="kw">&lt;/label&gt;</span></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>      </span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>      // Itt a spread operátorral adjuk meg a tulajdonságokat</span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a>      <span class="kw">&lt;input</span> <span class="va">{</span><span class="op">...</span>props<span class="op">.</span><span class="at">input</span><span class="va">}</span> <span class="kw">/&gt;</span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a>    <span class="kw">&lt;/div&gt;</span></span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a><span class="co">// Ezek után a renderelésnél</span></span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a><span class="fu">&lt;Input</span></span>
<span id="cb19-14"><a href="#cb19-14" tabindex="-1"></a>        <span class="ot">label</span><span class="op">=</span><span class="st">&quot;Amount&quot;</span></span>
<span id="cb19-15"><a href="#cb19-15" tabindex="-1"></a>        <span class="ot">input</span><span class="op">=</span><span class="va">{</span>{</span>
<span id="cb19-16"><a href="#cb19-16" tabindex="-1"></a>          <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;amount_&#39;</span> <span class="op">+</span> props<span class="op">.</span><span class="at">id</span><span class="op">,</span></span>
<span id="cb19-17"><a href="#cb19-17" tabindex="-1"></a>          <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;number&#39;</span><span class="op">,</span></span>
<span id="cb19-18"><a href="#cb19-18" tabindex="-1"></a>          <span class="dt">min</span><span class="op">:</span> <span class="st">&#39;1&#39;</span><span class="op">,</span></span>
<span id="cb19-19"><a href="#cb19-19" tabindex="-1"></a>          <span class="dt">max</span><span class="op">:</span> <span class="st">&#39;5&#39;</span><span class="op">,</span></span>
<span id="cb19-20"><a href="#cb19-20" tabindex="-1"></a>          <span class="dt">step</span><span class="op">:</span> <span class="st">&#39;1&#39;</span><span class="op">,</span></span>
<span id="cb19-21"><a href="#cb19-21" tabindex="-1"></a>          <span class="dt">defaultValue</span><span class="op">:</span> <span class="st">&#39;1&#39;</span><span class="op">,</span></span>
<span id="cb19-22"><a href="#cb19-22" tabindex="-1"></a>        }<span class="va">}</span></span>
<span id="cb19-23"><a href="#cb19-23" tabindex="-1"></a>      <span class="fu">/&gt;</span></span></code></pre></div>
<p>A fenti példában az input elem kap egy id, típus, minimum, maximum,
lépés és alapértelmezett érték tulajdonságot is.</p>
<div id="default-props-és-type-checking" class="section level3">
<h3>default props és type checking</h3>
<p>Lehetőség van default értékeket is megadni a komponenshez tartozó
<code>defaultProps</code> property-vel, amelyhez egy objektumot
rendelhetünk. A default értékek felülírása úgy történik, hogy megadjuk
az adott prop értékét a beillesztésnél.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>MyComponent<span class="op">.</span><span class="at">defaultProps</span> <span class="op">=</span> { <span class="dt">location</span><span class="op">:</span> <span class="st">&#39;San Francisco&#39;</span> }</span></code></pre></div>
<p>A React type checkinget is lehetővé tesz a propokra, hasonló módon,
mint a default értékek megadását. Az isRequired részt azt jelzi, hogy az
adott propot kötelező megadni. A propTypes-t külön kell importálni.</p>
<p>Bővebb információ <a
href="https://reactjs.org/docs/typechecking-with-proptypes.html">itt</a></p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="im">import</span> PropTypes <span class="im">from</span> <span class="st">&#39;prop-types&#39;</span><span class="op">;</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>MyComponent<span class="op">.</span><span class="at">propTypes</span> <span class="op">=</span> { </span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>  <span class="dt">handleClick</span><span class="op">:</span> PropTypes<span class="op">.</span><span class="at">func</span><span class="op">.</span><span class="at">isRequired</span><span class="op">,</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>  <span class="dt">quantity</span><span class="op">:</span> PropTypes<span class="op">.</span><span class="at">number</span><span class="op">,</span></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>  <span class="dt">switch</span><span class="op">:</span> PropTypes<span class="op">.</span><span class="at">string</span>}</span></code></pre></div>
</div>
<div id="adat--és-függvénytovábbítás" class="section level3">
<h3>Adat- és függvénytovábbítás</h3>
<p>A szülő komponensek adatokat és függvényhivatkozásokat adhatnak át a
gyermekeknek, de fordítva nem működik. Azokat az adatokat, amelyeket
több gyermeknek is kezelnie kell, a szülő komponensnek kell adnunk, majd
props révén továbbítani a gyermek komponenseknek. Ugyanígy, a gyermek
komponensek propként megkaphatják a szülőn definiált függvényeket,
amelyek felhasználhatók arra, hogy adatokat továbbítsunk “felfelé”.
Ezáltal pl. egy gyermek komponens is változtatni tudja a szülő
state-jét, ha a továbbított függvényben a state-et felülíró függvényt
használunk.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ContactManager</span>(props) {</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>  <span class="kw">const</span> [contacts<span class="op">,</span> setContacts] <span class="op">=</span> <span class="fu">useState</span>(props<span class="op">.</span><span class="at">data</span>)<span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>  <span class="kw">function</span> <span class="fu">addPerson</span>(name) {</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a>    <span class="fu">setContacts</span>([<span class="op">...</span>contacts<span class="op">,</span> name])<span class="op">;</span></span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>  }</span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a>    <span class="kw">&lt;div&gt;</span></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a>      <span class="fu">&lt;AddPersonForm</span> <span class="ot">handleSubmit</span><span class="op">=</span><span class="va">{</span>addPerson<span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a>      <span class="fu">&lt;PeopleList</span> <span class="ot">data</span><span class="op">=</span><span class="va">{</span>contacts<span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a>    <span class="kw">&lt;/div&gt;</span></span>
<span id="cb22-13"><a href="#cb22-13" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb22-14"><a href="#cb22-14" tabindex="-1"></a>} </span></code></pre></div>
<p>A gyermek komponensen definiálni kell egy függvényt, amely a
props.handleSubmit révén hívni tudja az addPerson függvényt.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="kw">function</span> <span class="fu">AddPersonForm</span>(props) {</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>  <span class="kw">const</span> [ person<span class="op">,</span> setPerson ] <span class="op">=</span> <span class="fu">useState</span>(<span class="st">&#39;&#39;</span>)<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>    </span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>  <span class="kw">function</span> <span class="fu">handleChange</span>(e) {</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>    <span class="fu">setPerson</span>(e<span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="at">value</span>)<span class="op">;</span></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>  }</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>    </span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>  <span class="kw">function</span> <span class="fu">handleSubmit</span>(e) {</span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>    props<span class="op">.</span><span class="fu">handleSubmit</span>(person)<span class="op">;</span></span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>    <span class="fu">setPerson</span>(<span class="st">&#39;&#39;</span>)<span class="op">;</span></span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a>    e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a>  }</span>
<span id="cb23-13"><a href="#cb23-13" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb23-14"><a href="#cb23-14" tabindex="-1"></a>    <span class="kw">&lt;form</span> <span class="ot">onSubmit</span><span class="op">=</span><span class="va">{</span>handleSubmit<span class="va">}</span><span class="kw">&gt;</span></span>
<span id="cb23-15"><a href="#cb23-15" tabindex="-1"></a>      <span class="kw">&lt;input</span> <span class="ot">type</span><span class="op">=</span><span class="st">&quot;text&quot;</span> </span>
<span id="cb23-16"><a href="#cb23-16" tabindex="-1"></a>        <span class="ot">placeholder</span><span class="op">=</span><span class="st">&quot;Add new contact&quot;</span> </span>
<span id="cb23-17"><a href="#cb23-17" tabindex="-1"></a>        <span class="ot">onChange</span><span class="op">=</span><span class="va">{</span>handleChange<span class="va">}</span> </span>
<span id="cb23-18"><a href="#cb23-18" tabindex="-1"></a>        <span class="ot">value</span><span class="op">=</span><span class="va">{</span>person<span class="va">}</span> <span class="kw">/&gt;</span></span>
<span id="cb23-19"><a href="#cb23-19" tabindex="-1"></a>      <span class="kw">&lt;button</span> <span class="ot">type</span><span class="op">=</span><span class="st">&quot;submit&quot;</span><span class="kw">&gt;</span>Add<span class="kw">&lt;/button&gt;</span></span>
<span id="cb23-20"><a href="#cb23-20" tabindex="-1"></a>    <span class="kw">&lt;/form&gt;</span></span>
<span id="cb23-21"><a href="#cb23-21" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb23-22"><a href="#cb23-22" tabindex="-1"></a>} </span></code></pre></div>
<p>A state tehát a szülő komponensben van eltárolva, de a gyermek
komponensek hozzáférhetnek ehhez és módosítani is tudják a prop formában
megkapott adatok és függvényreferenciák révén.</p>
<p>Ez a folyamat komplex alkalmazások esetében rendkívül bonyolulttá tud
válni. Ennek kezelésére született a Redux, amelyet a front-end
könyvtárak (React mellett jQuery, Angular) használhatnak.</p>
</div>
</div>
<div id="state" class="section level2">
<h2>State</h2>
<p>Míg a props változtathatatlan, a komponensek rendelkezhetnek
state-tel, amely a felhasználói interakció következtében változhat, és a
React ennek függvényében egyes komponenseket újrarenderelhet.</p>
<div id="class-komponensek-state-je" class="section level3">
<h3>Class komponensek state-je</h3>
<p>A state a class komponensek esetében ugyancsak egy objektum, és ez
módosítható, leggyakrabban event handlerekben. A state-hez a this.state
révén lehet hozzáférni, módosítani pedig a this.setState() metódussal.
Ha ez utóbbi történik, a React automatikusan újrarendereli a komponenst.
Ezáltal elkerülhető, hogy többször kelljen a ReactDOM.render metódust
használni.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="kw">class</span> Hello <span class="kw">extends</span> React<span class="op">.</span><span class="at">Component</span> {</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>  state <span class="op">=</span> {</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;James&quot;</span></span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>  }</span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a>  <span class="fu">render</span>() {</span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>    <span class="cf">return </span><span class="kw">&lt;h1&gt;</span>Hello <span class="va">{</span><span class="kw">this</span><span class="op">.</span><span class="at">state</span><span class="op">.</span><span class="at">name</span><span class="va">}</span>.<span class="kw">&lt;/h1&gt;</span><span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>  }</span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a>}</span>
<span id="cb24-10"><a href="#cb24-10" tabindex="-1"></a></span>
<span id="cb24-11"><a href="#cb24-11" tabindex="-1"></a><span class="kw">this</span><span class="op">.</span><span class="fu">setState</span>({ </span>
<span id="cb24-12"><a href="#cb24-12" tabindex="-1"></a>  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;James&quot;</span><span class="op">,</span></span>
<span id="cb24-13"><a href="#cb24-13" tabindex="-1"></a>  <span class="dt">age</span><span class="op">:</span> <span class="dv">25</span></span>
<span id="cb24-14"><a href="#cb24-14" tabindex="-1"></a>})<span class="op">;</span> </span></code></pre></div>
<p>A state-et a constructor függvényben is létrehozhatjuk, ebben az
esetben this.state-ként kell rá hivatkozni:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="kw">class</span> Hello <span class="kw">extends</span> React<span class="op">.</span><span class="at">Component</span> {</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>  <span class="fu">constructor</span>(props) {</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>    <span class="kw">super</span>(props)<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">state</span> <span class="op">=</span> {</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>      <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;James&quot;</span></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>    }</span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>  }</span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a>  <span class="fu">render</span>() {</span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a>    <span class="cf">return</span> (</span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a>      <span class="kw">&lt;div&gt;</span></span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a>        <span class="kw">&lt;h1&gt;</span>Hello <span class="va">{</span><span class="kw">this</span><span class="op">.</span><span class="at">state</span><span class="op">.</span><span class="at">name</span><span class="va">}</span><span class="kw">&lt;/h1&gt;</span></span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a>      <span class="kw">&lt;/div&gt;</span></span>
<span id="cb25-13"><a href="#cb25-13" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb25-14"><a href="#cb25-14" tabindex="-1"></a>  }</span>
<span id="cb25-15"><a href="#cb25-15" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p>Azokat a komponenseket, amelyek rendelkeznek state-tel
<code>stateful</code>-nak, a többit <code>stateless</code>-nek
nevezzük.</p>
<p>Az eredeti state értékeket a komponens kaphatja a props-ból is.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="kw">class</span> Hello <span class="kw">extends</span> React<span class="op">.</span><span class="at">Component</span> {</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>  state <span class="op">=</span> {</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>    <span class="dt">name</span><span class="op">:</span> <span class="kw">this</span><span class="op">.</span><span class="at">props</span><span class="op">.</span><span class="at">name</span></span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>  }</span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a>  <span class="fu">render</span>() {</span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a>    <span class="cf">return </span><span class="kw">&lt;h1&gt;</span>Hello <span class="va">{</span><span class="kw">this</span><span class="op">.</span><span class="at">state</span><span class="op">.</span><span class="at">name</span><span class="va">}</span>.<span class="kw">&lt;/h1&gt;</span><span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a>  }</span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a>}</span></code></pre></div>
<p>A setState metódus argumentuma lehet egy objektum azokkal a state
értékekkel, amelyeket módosítani szeretnénk, de másik megoldás, hogy
függvényt kap argumentumként, amely hozzáfér az aktuális state
állapothoz és a propokhoz, ami akkor lehet hasznos, ha a korábbi értékek
alapján akarunk új értéket adni. Ennek az első függvénynek a return
értéke legyen az új state objektum.</p>
<p>A második argumentum lehet egy callback függvény, amely akkor fut le,
ha a state frissült. Ez azért lehet fontos, mert a state update-et a
React optimalizálja, és nem szinkron módon hajtja végre, ezért ha a
state update után szeretnénk valami műveletet elvégezni, azt ebben a
függvényben tudjuk megtenni, mert egyébként elképzelhető, hogy a parancs
még az előző állapottal fut le. Ez a második argumentum opcionális.</p>
<p>A state értékeihez a <code>this.state</code> objektum révén férünk
hozzá, de ez destrukturálható is, akárcsak az instancia egésze is,
amelyre a <code>this</code> mutat.</p>
</div>
<div id="a-függvény-komponensek-state-je-usestate-hook"
class="section level3">
<h3>A függvény komponensek state-je: useState hook</h3>
<p>Korábban csak a class komponensek rendelkezhettek state-tel, de
újonnan már a függvény komponensek is, a <code>useState</code> hook
révén. Ehhez importálni kell (nevesített importtal):</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="im">import</span> React<span class="op">,</span> { useState } <span class="im">from</span> <span class="st">&#39;react&#39;</span><span class="op">;</span> </span></code></pre></div>
<p>A <code>useState()</code> egy argumentumot kap (a state
kezdőértékét), return értéke pedig egy array: ennek két eleme a
jelenlegi state és egy függvény, amely a state módosítását teszi
lehetővé. Ezeket array destrukturálással szokás változókba menteni. Több
state változó is létrehozható a useState ismételt hívásával.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="kw">function</span> <span class="fu">Hello</span>() {</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>  <span class="kw">const</span> [name<span class="op">,</span> setName] <span class="op">=</span> <span class="fu">useState</span>(<span class="st">&quot;David&quot;</span>)<span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a>  <span class="cf">return </span><span class="kw">&lt;h1&gt;</span>Hello <span class="va">{</span>name<span class="va">}</span>.<span class="kw">&lt;/h1&gt;</span><span class="op">;</span></span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>}</span></code></pre></div>
<p><em>A kapott párt általában az [x, setX] formában destrukturáljuk.
Előbbi az eredeti állapot, utóbbi a függvény neve.</em></p>
<p>Ezután a setX(val) függvényhívás x állapotértékét val-ra
változtatja.</p>
<p>Ha a state változtatása a korábbi state értékén alapul, függvényként
kell megadni:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="fu">setCounter</span>(prevState <span class="kw">=&gt;</span> prevState <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
</div>
<div id="komplex-state-ek-usereducer-hook" class="section level3">
<h3>Komplex state-ek: useReducer hook</h3>
<p>A <code>useReducer</code> hookkal lehetőség van összevontani kezelni
state-eket. Ez különösen hasznos, ha egy state érték egy vagy töb másik
state értéktől függ. Ilyen esetekben felmerülhet problémaként, hogy a
React a state-ek frissítését ütemezi, és előfordulhat, hogy egy korábbi
state értéket továbbít, mert az még nem frissült. Ennek elkerülésére
szolgált, hogy ha a korábbi state-en alapuló módosítást hajtunk végre
(pl. elemet adunk hozzá array-hez), akkor függvényként adjuk meg az új
state-et, amely paraméterként garantáltan a legfrissebb állapotot kapja
meg. Ez azonban nem működik, ha más state-ek alapján dolgozunk.</p>
<p>Kerülő megoldás lehet a useEffect hook használata és élesítése, ha a
másik state értéke változik, és így ennek legfrissebb értéke alapján
tudjuk megadni az ettől függő állapotértéket. Egy másik megoldás a
reducerek használata.</p>
<p>Ehhez a komponensen kívül létrehozunk egy reducer függvényt, amely a
kapott akciók alapján módosítja az aktuális state-et (valójában új state
objektumot hoz létre, hiszen a React csak így tudja felismerni az
állapotváltozást és hogy újra kell renderlni komponenseket).</p>
<p>Ennek első argumentuma a korábbi state állapot (a React garantálja,
hogy a legfrissebbet kapja), amelyet felhasználhatunk, ha például ezen
alapul az új state (pl. számláló), vagy ha az adott akció csak az
állapot egy részét módosítja, a többit pedig másolni szeretnénk. Másik
argumentuma az akció, amely jellemzően egy objektum, és rendelkezik
<code>type</code> tulajdonsággal, emellett pedig opcionálisan további
adatokat (<code>payload</code>) is tartalmazhat (pl. az alábbi példában
a val property-t):</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="kw">const</span> emailReducer <span class="op">=</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> {</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>  <span class="cf">if</span> (action<span class="op">.</span><span class="at">type</span> <span class="op">===</span> <span class="st">&#39;USER_INPUT&#39;</span>) {</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>    <span class="cf">return</span> { <span class="dt">value</span><span class="op">:</span> action<span class="op">.</span><span class="at">val</span><span class="op">,</span> <span class="dt">isValid</span><span class="op">:</span> action<span class="op">.</span><span class="at">val</span><span class="op">.</span><span class="fu">includes</span>(<span class="st">&#39;@&#39;</span>) }<span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>  }</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a>  <span class="cf">if</span> (action<span class="op">.</span><span class="at">type</span> <span class="op">===</span> <span class="st">&#39;INPUT_BLUR&#39;</span>) {</span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>    <span class="cf">return</span> { <span class="dt">value</span><span class="op">:</span> state<span class="op">.</span><span class="at">value</span><span class="op">,</span> <span class="dt">isValid</span><span class="op">:</span> state<span class="op">.</span><span class="at">value</span><span class="op">.</span><span class="fu">includes</span>(<span class="st">&#39;@&#39;</span>) }<span class="op">;</span></span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a>  }</span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a>  <span class="cf">return</span> { <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;&#39;</span><span class="op">,</span> <span class="dt">isValid</span><span class="op">:</span> <span class="kw">false</span> }<span class="op">;</span></span>
<span id="cb30-9"><a href="#cb30-9" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p>Ahhoz, hogy elkerüljük az elgépelésből adódó hibákat az akciók
típusainak megadása során, a lehetséges akciókat egy külön objektum
key-value párjaiként is megadhatjuk, és az akciók élesítésekor, illetve
a reducer függvényben ennek az objektumnak a property-jeit
használhatjuk.</p>
<p>A komponensben magában a <code>useState</code>-hez hasonlóan
használjuk a <code>useReducer</code>-t. Ennek első paramétere a fent
definiált reducer függvény, a második paramétere pedig egy kiinduló
state. Return értéke egy array, amelyet destrukturálunk: egy állapot
változót és egy dispatch függvényt kapunk.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="kw">const</span> [emailState<span class="op">,</span> dispatchEmail] <span class="op">=</span> <span class="fu">useReducer</span>(emailReducer<span class="op">,</span> {</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>    <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;&#39;</span><span class="op">,</span></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>    <span class="dt">isValid</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>  })<span class="op">;</span></span></code></pre></div>
<p>Ezután a handler függvényekben, amelyekben egyébként a state-et
változtatnánk, egy akciót (egy objektumot) küldünk el a dispatch
függvény paramétereként, amellyel módosítjuk a state-et. A state-et
ugyanúgy használhatjuk, mint korábban, de mivel sokszor objektum
formájú, ezért az adott property-re kell hivatkozni vagy
destrukturálni.</p>
<pre><code>const emailChangeHandler = (event) =&gt; {
    dispatchEmail({ type: &#39;USER_INPUT&#39;, val: event.target.value });

    setFormIsValid(event.target.value.includes(&#39;@&#39;) &amp;&amp; passWordState.isValid);
  };
  
const validateEmailHandler = () =&gt; {
    dispatchEmail({ type: &#39;INPUT_BLUR&#39; });
  };</code></pre>
<p>A reducereket használhatjuk a Contextben is: ebben az esetben a
setter függvény(eke)t, amelye(ke)t egyébként a useState hívásával
kapnánk, külön hozzuk létre, és ebben a <code>dispatch()</code>
függvényt használjuk.</p>
<p>Jó gyakorlat, hogy maga a logika ezekben a külön függvényekben
(<code>action creator</code>) van megírva, és a
<code>dispatch()</code>-nek payloadként a kész értékeket adjuk, és így a
reducer függvénynek csak létre kell ebből hoznia az új objektumot:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="kw">const</span> cartReducer <span class="op">=</span> (state<span class="op">,</span> action) <span class="kw">=&gt;</span> {</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>  <span class="kw">const</span> { type<span class="op">,</span> payload } <span class="op">=</span> action<span class="op">;</span></span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>  <span class="cf">switch</span> (type) {</span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a>    <span class="cf">case</span> CART_ACTION_TYPES<span class="op">.</span><span class="at">SET_CART_ITEMS</span><span class="op">:</span></span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a>      <span class="cf">return</span> {</span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a>        <span class="op">...</span>state<span class="op">,</span></span>
<span id="cb33-8"><a href="#cb33-8" tabindex="-1"></a>        <span class="op">...</span>payload<span class="op">,</span></span>
<span id="cb33-9"><a href="#cb33-9" tabindex="-1"></a>      }<span class="op">;</span></span>
<span id="cb33-10"><a href="#cb33-10" tabindex="-1"></a>    <span class="cf">case</span> CART_ACTION_TYPES<span class="op">.</span><span class="at">SET_IS_CART_OPEN</span><span class="op">:</span></span>
<span id="cb33-11"><a href="#cb33-11" tabindex="-1"></a>      <span class="cf">return</span> {</span>
<span id="cb33-12"><a href="#cb33-12" tabindex="-1"></a>        <span class="op">...</span>state<span class="op">,</span></span>
<span id="cb33-13"><a href="#cb33-13" tabindex="-1"></a>        <span class="dt">isCartOpen</span><span class="op">:</span> payload<span class="op">,</span></span>
<span id="cb33-14"><a href="#cb33-14" tabindex="-1"></a>      }<span class="op">;</span></span>
<span id="cb33-15"><a href="#cb33-15" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb33-16"><a href="#cb33-16" tabindex="-1"></a>      <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="vs">`Unhandled type of </span><span class="sc">${</span>type<span class="sc">}</span><span class="vs"> in cartReducer`</span>)<span class="op">;</span></span>
<span id="cb33-17"><a href="#cb33-17" tabindex="-1"></a>  }</span>
<span id="cb33-18"><a href="#cb33-18" tabindex="-1"></a>}</span></code></pre></div>
<p>Util függvényként létrehozhatunk egy <code>createAction()</code>
függvényt, amely egyszerűsíti a dispatch-ek írását:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="co">// reducer.utils.js</span></span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a><span class="im">export</span> <span class="kw">const</span> createAction <span class="op">=</span> (type<span class="op">,</span> payload) <span class="kw">=&gt;</span> ({ type<span class="op">,</span> payload })</span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a><span class="co">// usage</span></span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a><span class="fu">dispatch</span>(<span class="fu">createAction</span>(<span class="st">&#39;INCREMENT&#39;</span><span class="op">,</span> newCount))<span class="op">;</span></span></code></pre></div>
</div>
<div id="react-context-api" class="section level3">
<h3>React Context API</h3>
<p>Sokszintű alkalmazásoknál a hagyományosan kezelt state-et sok szinten
kell átküldeni anélkül, hogy azt az adott szinten használnánk. Ennek egy
jó alternatívája lehet a Context API.</p>
<p><strong>LÉTREHOZÁS:</strong> Külön mappában (pl. context, store,
state) létrehozott .js file-okban is kezelhetjük a komplexebb globális
state-eket. Ebben importálni kell a Reactot, majd a
<code>React.createContext()</code> metódussal hozható létre a kontextus,
amelynek jellemző paramétere egy objektum a state változókkal. Ezt egy
változóba mentjük, és exportáljuk.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="im">import</span> React <span class="im">from</span> <span class="st">&#39;react&#39;</span><span class="op">;</span></span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a><span class="kw">const</span> AuthContext <span class="op">=</span> React<span class="op">.</span><span class="fu">createContext</span>({</span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a>  <span class="dt">isLoggedIn</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a>  <span class="dt">onLogout</span><span class="op">:</span> () <span class="kw">=&gt;</span> {}<span class="op">,</span></span>
<span id="cb35-6"><a href="#cb35-6" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb35-7"><a href="#cb35-7" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> AuthContext<span class="op">;</span></span></code></pre></div>
<p>Ez azért jó, mert így az IDE hozzáfér ezekhez, és a programkód írása
során javasolja ezeket a property neveket.</p>
<p><strong>RENDELKEZÉSRE BOCSÁTÁS (PROVIDE):</strong> Ezután a
létrehozott kontextus objektum importálható a megfelelő file-okba, ahol
azokat a komponenseket, amelyeknek hozzáférést akarunk adni az ebben
tárolt változókhoz, be kell csomagolnunk.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="cf">return</span> (</span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a>    <span class="fu">&lt;AuthContext.Provider</span> </span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a>      <span class="ot">value</span><span class="op">=</span><span class="va">{</span>{</span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a>        <span class="dt">isLoggedIn</span><span class="op">:</span> isLoggedIn<span class="op">,</span> <span class="co">// state variable from useState or useReducer</span></span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a>        <span class="dt">onLogout</span><span class="op">:</span> logoutHandler<span class="op">,</span></span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a>      }<span class="va">}</span></span>
<span id="cb36-8"><a href="#cb36-8" tabindex="-1"></a>    <span class="fu">&gt;</span></span>
<span id="cb36-9"><a href="#cb36-9" tabindex="-1"></a>      <span class="fu">&lt;MainHeader</span> <span class="ot">isAuthenticated</span><span class="op">=</span><span class="va">{</span>isLoggedIn<span class="va">}</span> <span class="ot">onLogout</span><span class="op">=</span><span class="va">{</span>logoutHandler<span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb36-10"><a href="#cb36-10" tabindex="-1"></a>      <span class="kw">&lt;main&gt;</span></span>
<span id="cb36-11"><a href="#cb36-11" tabindex="-1"></a>        <span class="va">{</span><span class="op">!</span>isLoggedIn <span class="op">&amp;&amp; </span><span class="fu">&lt;Login</span> <span class="ot">onLogin</span><span class="op">=</span><span class="va">{</span>loginHandler<span class="va">}</span> <span class="fu">/&gt;</span><span class="va">}</span></span>
<span id="cb36-12"><a href="#cb36-12" tabindex="-1"></a>        <span class="va">{</span>isLoggedIn <span class="op">&amp;&amp; </span><span class="fu">&lt;Home</span> <span class="ot">onLogout</span><span class="op">=</span><span class="va">{</span>logoutHandler<span class="va">}</span> <span class="fu">/&gt;</span><span class="va">}</span></span>
<span id="cb36-13"><a href="#cb36-13" tabindex="-1"></a>      <span class="kw">&lt;/main&gt;</span></span>
<span id="cb36-14"><a href="#cb36-14" tabindex="-1"></a>    <span class="fu">&lt;/AuthContext.Provider&gt;</span></span>
<span id="cb36-15"><a href="#cb36-15" tabindex="-1"></a>  )<span class="op">;</span></span></code></pre></div>
<p><strong>HASZNÁLAT (LISTENING):</strong> Ezek után a használó
komponenseket hozzá kell kötni a kontextushoz. Erre két mód van:</p>
<p><strong>Context Consumer wrapper</strong>:<br />
A megfelelő komponenseket a Consumer wrapperbe csomagoljuk, és ezen
belül egy függvényben return-öljük a JSX kódot. Ehhez viszont a
Provider-ben meg kell adni a value értékeként ugyanezt az objektumot.
Ebben viszont a konkrét érték helyett hivatkozhatunk az egyébként
használt state változóra. Ugyancsak ebben függvényeket is hozzáadhatunk,
amelyhez szintén hozzáférnek majd a child komponensek. Ha ez megtörtént,
már nem kell a props-szal továbbítani ezeket az információkat, mert a
kontextus objektum részeként hozzáférnek a komponensek.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="co">// App.js-ben</span></span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a><span class="cf">return</span> (</span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>    <span class="fu">&lt;AuthContext.Provider</span></span>
<span id="cb37-4"><a href="#cb37-4" tabindex="-1"></a>      <span class="ot">value</span><span class="op">=</span><span class="va">{</span>{</span>
<span id="cb37-5"><a href="#cb37-5" tabindex="-1"></a>        <span class="dt">isLoggedIn</span><span class="op">:</span> isLoggedIn<span class="op">,</span> <span class="co">// Ez a fent létrehozott state változó</span></span>
<span id="cb37-6"><a href="#cb37-6" tabindex="-1"></a>        <span class="dt">onLogout</span><span class="op">:</span> logoutHandler<span class="op">,</span></span>
<span id="cb37-7"><a href="#cb37-7" tabindex="-1"></a>      }<span class="va">}</span></span>
<span id="cb37-8"><a href="#cb37-8" tabindex="-1"></a>    <span class="fu">&gt;</span></span>
<span id="cb37-9"><a href="#cb37-9" tabindex="-1"></a>      <span class="fu">&lt;MainHeader</span> <span class="fu">/&gt;</span>  // Itt már nincs a props-szal továbbítva</span>
<span id="cb37-10"><a href="#cb37-10" tabindex="-1"></a>      <span class="kw">&lt;main&gt;</span></span>
<span id="cb37-11"><a href="#cb37-11" tabindex="-1"></a>        <span class="va">{</span><span class="op">!</span>isLoggedIn <span class="op">&amp;&amp; </span><span class="fu">&lt;Login</span> <span class="ot">onLogin</span><span class="op">=</span><span class="va">{</span>loginHandler<span class="va">}</span> <span class="fu">/&gt;</span><span class="va">}</span></span>
<span id="cb37-12"><a href="#cb37-12" tabindex="-1"></a>        <span class="va">{</span>isLoggedIn <span class="op">&amp;&amp; </span><span class="fu">&lt;Home</span> <span class="ot">onLogout</span><span class="op">=</span><span class="va">{</span>logoutHandler<span class="va">}</span> <span class="fu">/&gt;</span><span class="va">}</span></span>
<span id="cb37-13"><a href="#cb37-13" tabindex="-1"></a>      <span class="kw">&lt;/main&gt;</span></span>
<span id="cb37-14"><a href="#cb37-14" tabindex="-1"></a>    <span class="fu">&lt;/AuthContext.Provider&gt;</span></span>
<span id="cb37-15"><a href="#cb37-15" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb37-16"><a href="#cb37-16" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb37-17"><a href="#cb37-17" tabindex="-1"></a><span class="co">MainHeader.js-ben már nem kell props-szal továbbítani a state változót és a logoutHandlert</span></span>
<span id="cb37-18"><a href="#cb37-18" tabindex="-1"></a><span class="co">Navigation.js-ben importálás után hozzáférünk a kontextushoz, amelyre tetszőleges </span></span>
<span id="cb37-19"><a href="#cb37-19" tabindex="-1"></a><span class="co">névvel hivatkozhatunk</span></span>
<span id="cb37-20"><a href="#cb37-20" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb37-21"><a href="#cb37-21" tabindex="-1"></a><span class="kw">const</span> Navigation <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb37-22"><a href="#cb37-22" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb37-23"><a href="#cb37-23" tabindex="-1"></a>    <span class="fu">&lt;AuthContext.Consumer&gt;</span></span>
<span id="cb37-24"><a href="#cb37-24" tabindex="-1"></a>      <span class="va">{</span>(ctx) <span class="kw">=&gt;</span> {</span>
<span id="cb37-25"><a href="#cb37-25" tabindex="-1"></a>        <span class="cf">return</span> (</span>
<span id="cb37-26"><a href="#cb37-26" tabindex="-1"></a>          <span class="kw">&lt;nav</span> <span class="ot">className</span><span class="op">=</span><span class="va">{</span>classes<span class="op">.</span><span class="at">nav</span><span class="va">}</span><span class="kw">&gt;</span></span>
<span id="cb37-27"><a href="#cb37-27" tabindex="-1"></a>            <span class="kw">&lt;ul&gt;</span></span>
<span id="cb37-28"><a href="#cb37-28" tabindex="-1"></a>              <span class="va">{</span>ctx<span class="op">.</span><span class="at">isLoggedIn</span> <span class="op">&amp;&amp;</span> (</span>
<span id="cb37-29"><a href="#cb37-29" tabindex="-1"></a>                <span class="kw">&lt;li&gt;</span></span>
<span id="cb37-30"><a href="#cb37-30" tabindex="-1"></a>                  <span class="kw">&lt;a</span> <span class="ot">href</span><span class="op">=</span><span class="st">&quot;/&quot;</span><span class="kw">&gt;</span>Users<span class="kw">&lt;/a&gt;</span></span>
<span id="cb37-31"><a href="#cb37-31" tabindex="-1"></a>                <span class="kw">&lt;/li&gt;</span></span>
<span id="cb37-32"><a href="#cb37-32" tabindex="-1"></a>              )<span class="va">}</span></span>
<span id="cb37-33"><a href="#cb37-33" tabindex="-1"></a>              <span class="va">{</span>ctx<span class="op">.</span><span class="at">isLoggedIn</span> <span class="op">&amp;&amp;</span> (</span>
<span id="cb37-34"><a href="#cb37-34" tabindex="-1"></a>                <span class="kw">&lt;li&gt;</span></span>
<span id="cb37-35"><a href="#cb37-35" tabindex="-1"></a>                  <span class="kw">&lt;a</span> <span class="ot">href</span><span class="op">=</span><span class="st">&quot;/&quot;</span><span class="kw">&gt;</span>Admin<span class="kw">&lt;/a&gt;</span></span>
<span id="cb37-36"><a href="#cb37-36" tabindex="-1"></a>                <span class="kw">&lt;/li&gt;</span></span>
<span id="cb37-37"><a href="#cb37-37" tabindex="-1"></a>              )<span class="va">}</span></span>
<span id="cb37-38"><a href="#cb37-38" tabindex="-1"></a>              <span class="va">{</span>ctx<span class="op">.</span><span class="at">isLoggedIn</span> <span class="op">&amp;&amp;</span> (</span>
<span id="cb37-39"><a href="#cb37-39" tabindex="-1"></a>                <span class="kw">&lt;li&gt;</span></span>
<span id="cb37-40"><a href="#cb37-40" tabindex="-1"></a>                  <span class="kw">&lt;button</span> <span class="ot">onClick</span><span class="op">=</span><span class="va">{</span>ctx<span class="op">.</span><span class="at">onLogout</span><span class="va">}</span><span class="kw">&gt;</span>Logout<span class="kw">&lt;/button&gt;</span></span>
<span id="cb37-41"><a href="#cb37-41" tabindex="-1"></a>                <span class="kw">&lt;/li&gt;</span></span>
<span id="cb37-42"><a href="#cb37-42" tabindex="-1"></a>              )<span class="va">}</span></span>
<span id="cb37-43"><a href="#cb37-43" tabindex="-1"></a>            <span class="kw">&lt;/ul&gt;</span></span>
<span id="cb37-44"><a href="#cb37-44" tabindex="-1"></a>          <span class="kw">&lt;/nav&gt;</span></span>
<span id="cb37-45"><a href="#cb37-45" tabindex="-1"></a>        )<span class="op">;</span></span>
<span id="cb37-46"><a href="#cb37-46" tabindex="-1"></a>      }<span class="va">}</span></span>
<span id="cb37-47"><a href="#cb37-47" tabindex="-1"></a>    <span class="fu">&lt;/AuthContext.Consumer&gt;</span></span>
<span id="cb37-48"><a href="#cb37-48" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb37-49"><a href="#cb37-49" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p><strong>useContext hook</strong>:<br />
Ennél egyszerűbb és jobban olvasható a <code>useContext</code> hook
használata. Importálás után egyszerűen egy változóba mentjük a
létrehozott kontextust, és ezután hozzáférünk ennek property-jeihez. A
ctx objektumot destrukturálhatjuk is külön változókba.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="kw">const</span> Navigation <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>  <span class="kw">const</span> ctx <span class="op">=</span> <span class="fu">useContext</span>(AuthContext)<span class="op">;</span></span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>  </span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a>    <span class="kw">&lt;nav</span> <span class="ot">className</span><span class="op">=</span><span class="va">{</span>classes<span class="op">.</span><span class="at">nav</span><span class="va">}</span><span class="kw">&gt;</span></span>
<span id="cb38-6"><a href="#cb38-6" tabindex="-1"></a>      <span class="kw">&lt;ul&gt;</span></span>
<span id="cb38-7"><a href="#cb38-7" tabindex="-1"></a>        <span class="va">{</span>ctx<span class="op">.</span><span class="at">isLoggedIn</span> <span class="op">&amp;&amp;</span> (</span>
<span id="cb38-8"><a href="#cb38-8" tabindex="-1"></a>          <span class="kw">&lt;li&gt;</span></span>
<span id="cb38-9"><a href="#cb38-9" tabindex="-1"></a>            <span class="kw">&lt;a</span> <span class="ot">href</span><span class="op">=</span><span class="st">&quot;/&quot;</span><span class="kw">&gt;</span>Users<span class="kw">&lt;/a&gt;</span></span>
<span id="cb38-10"><a href="#cb38-10" tabindex="-1"></a>          <span class="kw">&lt;/li&gt;</span></span>
<span id="cb38-11"><a href="#cb38-11" tabindex="-1"></a>        )<span class="va">}</span></span>
<span id="cb38-12"><a href="#cb38-12" tabindex="-1"></a>        <span class="va">{</span>ctx<span class="op">.</span><span class="at">isLoggedIn</span> <span class="op">&amp;&amp;</span> (</span>
<span id="cb38-13"><a href="#cb38-13" tabindex="-1"></a>          <span class="kw">&lt;li&gt;</span></span>
<span id="cb38-14"><a href="#cb38-14" tabindex="-1"></a>            <span class="kw">&lt;a</span> <span class="ot">href</span><span class="op">=</span><span class="st">&quot;/&quot;</span><span class="kw">&gt;</span>Admin<span class="kw">&lt;/a&gt;</span></span>
<span id="cb38-15"><a href="#cb38-15" tabindex="-1"></a>          <span class="kw">&lt;/li&gt;</span></span>
<span id="cb38-16"><a href="#cb38-16" tabindex="-1"></a>        )<span class="va">}</span></span>
<span id="cb38-17"><a href="#cb38-17" tabindex="-1"></a>        <span class="va">{</span>ctx<span class="op">.</span><span class="at">isLoggedIn</span> <span class="op">&amp;&amp;</span> (</span>
<span id="cb38-18"><a href="#cb38-18" tabindex="-1"></a>          <span class="kw">&lt;li&gt;</span></span>
<span id="cb38-19"><a href="#cb38-19" tabindex="-1"></a>            <span class="kw">&lt;button</span> <span class="ot">onClick</span><span class="op">=</span><span class="va">{</span>ctx<span class="op">.</span><span class="at">onLogout</span><span class="va">}</span><span class="kw">&gt;</span>Logout<span class="kw">&lt;/button&gt;</span></span>
<span id="cb38-20"><a href="#cb38-20" tabindex="-1"></a>          <span class="kw">&lt;/li&gt;</span></span>
<span id="cb38-21"><a href="#cb38-21" tabindex="-1"></a>        )<span class="va">}</span></span>
<span id="cb38-22"><a href="#cb38-22" tabindex="-1"></a>      <span class="kw">&lt;/ul&gt;</span></span>
<span id="cb38-23"><a href="#cb38-23" tabindex="-1"></a>    <span class="kw">&lt;/nav&gt;</span></span>
<span id="cb38-24"><a href="#cb38-24" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb38-25"><a href="#cb38-25" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p>Ezzel párhuzamosan, ahol közvetlenül használjuk is, illetve, ahol
fontos, hogy más függvények is továbbíthatók legyenek (pl. Button
komponens), továbbra is a props révén továbbítjuk a szükséges értékeket
és függvényeket.</p>
<p>Lehetséges a Context Providert a context js file-jában komponensként
létrehozni, amelybe áttehetünk minden state-változót, függvényt, amit
kezelnie kell, és ezt a komponenst is exportálhatjuk. Ezek után
nevesített importtal betehetjük akár az index.js file-ba is, ezáltal az
egész applikáció számára rendelkezésre bocsátva ezt a kontextust. Ezek
után minden komponens file-ban a kontextus importálása után a useContext
hookkal hozzáférhetünk ezekhez a változókhoz és függvényekhez. Szintén
az értékeket is megadhatjuk külön változóban és itt már csak a változót
adjuk a value propnak.</p>
<p>A kibővített context file:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a><span class="im">import</span> React<span class="op">,</span> { useState<span class="op">,</span> useEffect } <span class="im">from</span> <span class="st">&#39;react&#39;</span><span class="op">;</span></span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a><span class="kw">const</span> AuthContext <span class="op">=</span> React<span class="op">.</span><span class="fu">createContext</span>({</span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a>  <span class="dt">isLoggedIn</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb39-5"><a href="#cb39-5" tabindex="-1"></a>  <span class="dt">onLogout</span><span class="op">:</span> () <span class="kw">=&gt;</span> {}<span class="op">,</span></span>
<span id="cb39-6"><a href="#cb39-6" tabindex="-1"></a>  <span class="dt">onLogin</span><span class="op">:</span> (email<span class="op">,</span> password) <span class="kw">=&gt;</span> {}<span class="op">,</span></span>
<span id="cb39-7"><a href="#cb39-7" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" tabindex="-1"></a><span class="im">export</span> <span class="kw">const</span> AuthContextProvider <span class="op">=</span> (props) <span class="kw">=&gt;</span> {</span>
<span id="cb39-10"><a href="#cb39-10" tabindex="-1"></a>  <span class="kw">const</span> [isLoggedIn<span class="op">,</span> setIsLoggedIn] <span class="op">=</span> <span class="fu">useState</span>(<span class="kw">false</span>)<span class="op">;</span></span>
<span id="cb39-11"><a href="#cb39-11" tabindex="-1"></a></span>
<span id="cb39-12"><a href="#cb39-12" tabindex="-1"></a>  <span class="fu">useEffect</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb39-13"><a href="#cb39-13" tabindex="-1"></a>    <span class="kw">const</span> storedLoginInfo <span class="op">=</span> localStorage<span class="op">.</span><span class="fu">getItem</span>(<span class="st">&#39;isLoggedIn&#39;</span>)<span class="op">;</span></span>
<span id="cb39-14"><a href="#cb39-14" tabindex="-1"></a></span>
<span id="cb39-15"><a href="#cb39-15" tabindex="-1"></a>    <span class="cf">if</span> (storedLoginInfo <span class="op">===</span> <span class="st">&#39;1&#39;</span>) {</span>
<span id="cb39-16"><a href="#cb39-16" tabindex="-1"></a>      <span class="fu">setIsLoggedIn</span>(<span class="kw">true</span>)<span class="op">;</span></span>
<span id="cb39-17"><a href="#cb39-17" tabindex="-1"></a>    }</span>
<span id="cb39-18"><a href="#cb39-18" tabindex="-1"></a>  }<span class="op">,</span> [])<span class="op">;</span></span>
<span id="cb39-19"><a href="#cb39-19" tabindex="-1"></a></span>
<span id="cb39-20"><a href="#cb39-20" tabindex="-1"></a>  <span class="kw">const</span> logoutHandler <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb39-21"><a href="#cb39-21" tabindex="-1"></a>    localStorage<span class="op">.</span><span class="fu">removeItem</span>(<span class="st">&#39;isLoggedIn&#39;</span>)<span class="op">;</span></span>
<span id="cb39-22"><a href="#cb39-22" tabindex="-1"></a>    <span class="fu">setIsLoggedIn</span>(<span class="kw">false</span>)<span class="op">;</span></span>
<span id="cb39-23"><a href="#cb39-23" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb39-24"><a href="#cb39-24" tabindex="-1"></a></span>
<span id="cb39-25"><a href="#cb39-25" tabindex="-1"></a>  <span class="kw">const</span> loginHandler <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb39-26"><a href="#cb39-26" tabindex="-1"></a>    localStorage<span class="op">.</span><span class="fu">setItem</span>(<span class="st">&#39;isLoggedIn&#39;</span><span class="op">,</span> <span class="st">&#39;1&#39;</span>)<span class="op">;</span></span>
<span id="cb39-27"><a href="#cb39-27" tabindex="-1"></a>    <span class="fu">setIsLoggedIn</span>(<span class="kw">true</span>)<span class="op">;</span></span>
<span id="cb39-28"><a href="#cb39-28" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb39-29"><a href="#cb39-29" tabindex="-1"></a></span>
<span id="cb39-30"><a href="#cb39-30" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb39-31"><a href="#cb39-31" tabindex="-1"></a>    <span class="fu">&lt;AuthContext.Provider</span></span>
<span id="cb39-32"><a href="#cb39-32" tabindex="-1"></a>      <span class="ot">value</span><span class="op">=</span><span class="va">{</span>{</span>
<span id="cb39-33"><a href="#cb39-33" tabindex="-1"></a>        <span class="dt">isLoggedIn</span><span class="op">:</span> isLoggedIn<span class="op">,</span></span>
<span id="cb39-34"><a href="#cb39-34" tabindex="-1"></a>        <span class="dt">onLogout</span><span class="op">:</span> logoutHandler<span class="op">,</span></span>
<span id="cb39-35"><a href="#cb39-35" tabindex="-1"></a>        <span class="dt">onLogin</span><span class="op">:</span> loginHandler<span class="op">,</span></span>
<span id="cb39-36"><a href="#cb39-36" tabindex="-1"></a>      }<span class="va">}</span></span>
<span id="cb39-37"><a href="#cb39-37" tabindex="-1"></a>    <span class="fu">&gt;</span></span>
<span id="cb39-38"><a href="#cb39-38" tabindex="-1"></a>      <span class="va">{</span>props<span class="op">.</span><span class="at">children</span><span class="va">}</span></span>
<span id="cb39-39"><a href="#cb39-39" tabindex="-1"></a>    <span class="fu">&lt;/AuthContext.Provider&gt;</span></span>
<span id="cb39-40"><a href="#cb39-40" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb39-41"><a href="#cb39-41" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb39-42"><a href="#cb39-42" tabindex="-1"></a></span>
<span id="cb39-43"><a href="#cb39-43" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> AuthContext<span class="op">;</span></span></code></pre></div>
<p>Korlátai: a context nehezen kezeli a gyakori state-változásokat. Erre
a Redux jobb megoldás. A rövid prop-láncokat nem szükséges lecserélni,
de ha hosszú props-láncaink vannak, érdemes lehet a Context API-t
használni.</p>
</div>
<div id="react-redux" class="section level3">
<h3>React-Redux</h3>
<p>A React appok state-jét, különösen nagy appok esetében célszerű lehet
a Redux-szal kezelni. A React.Context-hez képest a Redux jobban képest
komplex, és gyakran frissülő state-et kezelni.</p>
<p>A <code>Context</code>-tel ellentétben, amelyből több is lehet, és
ezekhez vagy az egész alkalmazás, vagy annak egy kisebb része férhet
hozzá, amelyet az adott kontextus <code>Provider</code> komponensébe
csomagoltunk, a <code>Redux</code> esetében egyetlen <code>store</code>
van, amelyhez a teljes alkalmazás hozzáfér.</p>
<p>Másik különbség, hogy a <code>Context</code> esetében, ha
<code>reducer</code> függvényeket használunk a komplex állapot
kezelésére, minden <code>reducer</code> külön <code>dispatch()</code>
függvényt kap, amelyet magát vagy egy ezt hívó
<code>action creator</code>-t adunk át a komponenseknek, hogy módosítani
tudják a state-et. A <code>Redux</code> esetében a komponensek az egész
állapothoz hozzáférnek, és ugyanazt a <code>dispatch()</code> függvényt
használják, amelyet egy vagy akár több külön <code>reducer</code> dolgoz
fel. Ezeket pedig egy <code>root reducer</code>-ben egységesítünk.</p>
<p><em>Természetesen a Redux kombinálható a hagyományos
state-kezeléssel, ha pl. lokálisan használat state-et is akarunk: pl.
komponens elrejtése. Nem ajánlatos viszont a Redux és a Context API
együttes használata.</em></p>
<p>A Redux használatához a <code>redux</code> mellett a
<code>react-redux</code> package-et használjuk. Ennek része a
<code>Provider</code> komponens, illetve a <code>connect</code>
függvény. Függvény komponensekhez pedig a <code>useSelector</code> és
<code>useDispatch</code> hookok.</p>
<p>A Redux használatát a <a
href="&#39;/redux-basics.html&#39;">redux-basics</a> oldalon foglaltam
össze.</p>
<p>Az egész alkalmazásunkat a <code>&lt;Provider&gt;</code> komponensbe
ágyazzuk, ezért ezt ott importáljuk (akár az index.js file-ban). Ez a
komponens két propot kap: a <code>store</code>-t és a child
komponenseket. Ehhez a <code>ReactRedux.Provider</code> hivatkozással
férhetünk hozzá, és az egyszerűség kedvéért új változóba menthetjük,
vagy nevesített import után a <code>Provider</code> komponens
formájában.</p>
<pre><code>const Provider = ReactRedux.Provider;</code></pre>
<p>Ezután a renderelés során a
<code>&lt;Provider&gt;&lt;/Provider&gt;</code> formában használhatjuk,
amely közé beágyazhatjuk az App komponenst, vagy annak részeit.</p>
</div>
</div>
<div id="event-handling" class="section level2">
<h2>Event handling</h2>
<p>Reactban az event handlereket <code>inline</code> formában a html
tagbe írva adhatjuk meg. Ellentétben a html-lel, az event handlerek neve
camelCase-ben van (pl. onClick), az event handler függvényt pedig
<code>{}</code> közé írhatjuk.</p>
<pre><code>&lt;button onClick={handleClick}&gt;
  My Button
&lt;/button&gt; 

// vagy class komponensnél

&lt;button onClick={this.handleClick}&gt;
  My Button
&lt;/button&gt; </code></pre>
<p>Event nevek: onClick, onChange (input mezőknél), onSubmit (a form
tag-ben)</p>
<p>A függvényeket korábban létrehozzuk a class/függvény komponens
részeként, és ezek hozzáférhetnek az event objektumhoz.</p>
<p>Ha class komponenseket használunk, akkor a függvények esetében
egyértelműen meg kell adni, <strong>mire mutasson a this</strong> a bind
metódussal, mert csak így fognak tudni a this révén hozzáférni a
komponenshez. Ez a JS általános működéséből ered: class-on belül
közvetve hívott függvényeknél a <code>this</code> nem meghatározott.
Ennek egyik megoldása a <code>bind</code> használata. Ha van
constructor, akkor ezt azon belül tudjuk megtenni, míg magát a függvényt
(metódust) ezen kívül, magában a komponensben hozzuk létre. Ezekre a
metódusokra aztán a <code>this.methodName</code> módon tudunk hivatkozni
és hívni azokat.</p>
<p>Ez a constructorba jön:</p>
<pre><code>this.funName = this.funName.bind(this)</code></pre>
<p>Másik lehetőség, hogy a callback függvény maga anonim arrow függvény.
Ebben az esetben nincs szükség a hívott függvényt a class-hoz kötni.</p>
<pre><code>&lt;button onClick={() =&gt; this.addItem()}&gt;Add&lt;/button&gt;</code></pre>
<p>Vannak olyan események, amelyeket viszont csak közvetlenül (az
<code>addEventListener</code>-rel) tudunk hozzáadni a window-hoz,
illetve documenthez. Erre a legjobb hely a
<code>componentDidMount()</code> életciklus metódus, illetve függvény
komponenseknél a useEffect() hook.</p>
</div>
<div id="életciklusokhoz-kapcsolódó-műveletek" class="section level2">
<h2>Életciklusokhoz kapcsolódó műveletek</h2>
<p>Az életciklus műveletek lehetővé teszik, hogy bizonyos műveleteket a
React komponensek életciklusának meghatározott eseményeinél hajtsunk
végre. Class komponensek esetében több metódus közül választhatunk, a
függvény komponensek esetében pedig a useEffect hook használható.</p>
<div id="class-komponensek" class="section level3">
<h3>Class komponensek</h3>
<p>Class komponensek esetében az életciklus műveletek a class fő
részébe, a constructor után, de a render előtt helyezhetők el. A
<code>componentWillMount()</code> azelőtt fut, mielőtt a komponens
először renderelődne. A <code>componentDidMount()</code> hozzáadható,
hogy például a komponens induló state-jét megadjuk: akkor fut, amikor a
komponenst az oldalra rendereljük. Ez hasznos lehet akkor is, ha event
handlert akarunk hozzáadni valamilyen DOM elemhez, illetve az API
hívások is ebbe a metódusba adhatók hozzá. Ha az adatok beérkezése után
a setState-et hívjuk, az a komponens újrarenderelését eredményezi a
megadott adatokkal. Hasonlóan a <code>componentWillUnmount()</code>
életciklus metódus közvetlenül a komponens eltávolítása előtt fut, a
<code>componentDidUpdate()</code> pedig akkor, ha az adott komponenst
frissítjük. A <code>shouldComponentUpdate()</code> metódus két
argumentumot fogad el (nextProps és nextState), amelyekben a props és a
state következő értékei találhatók objektumokként. Ez felhasználható
arra, hogy a komponensek csak bizonyos feltételek esetén (pl. az új
props különbözik az előzőtől) frissüljenek. A metódusnak booleant kell
visszaadnia, amely ha true, akkor frissül, ha false, akkor nem frissül a
komponens.</p>
<pre><code>class OnlyEvens extends React.Component {
  constructor(props) {
    super(props);
  }
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps.value % 2 == 0;
  }
  render() {
    return &lt;h1&gt;{this.props.value}&lt;/h1&gt;;
  }
}</code></pre>
</div>
<div id="useeffect" class="section level3">
<h3>useEffect</h3>
<p>Függvény komponensek esetében a React újabban a
<code>useEffect()</code> hookot teszi elérhetővé, amely kombinálja a
fenti három életciklus metódust, amely egy callback függvény
argumentumot fogad el. Használathoz importálni kell:</p>
<pre><code>import React, { useState, useEffect } from &#39;react&#39;;</code></pre>
<p>Ha a useEffect() függvényt beillesztjük a komponenst létrehozó
függvényünkben az a renderelést követően, és/vagy minden frissítéskor
lefut, attól függően, hogyan adjuk meg. Ha csak bizonyos állapotok
frissítését szeretnénk kezelni, egy második paraméterrel tehetjük,
amelyben megadjuk, hogy csak akkor akarjuk futtatni, ha az adott változó
értéke megváltozik. Végül az unmountot úgy tudjuk kezelni, ha a függvény
return értékeként adunk meg egy olyan függvényt, amely a “takarítást”
végzi (<code>cleanup function</code>).</p>
<p><em>Egy komponensben többször is használhatjuk a useEffect()
függvényt.</em></p>
<p>Az alábbi useEffect az összes lehetséges paramétert tartalmazza:</p>
<ol style="list-style-type: decimal">
<li>Élső paramétere a callback függvény, amelyben egy időzítéssel (ezt
mentjük identifier néven, hogy törölni tudjuk) oldjuk meg, hogy a state
módosítás csak bizonyos idő után élesedjen (0.5s).</li>
<li>A függvénynek return értéke is van, ami egy cleanup függvényt
eredményez, amely a függvény újbóli lefutásai előtt fut le közvetlenül.
Ez azt eredményezi, hogy mikor a dependencies részben feltüntetett
változók értéke megváltozik, akkor mielőtt új időzítést indítanánk, a
korábban indítottat leállítjuk. Ezzel ebben az esetben azt oldjuk meg,
hogy ne fusson le a form validálás minden billentyűleütés után, csak ha
a felhasználó hosszabb szünetet tart.</li>
<li>A dependency résszel kapcsolatban az a fontos, hogy azokat tüntessük
itt fel, amelyeket a függvény eleve használ, és változni tudnak. Nem
szükséges itt feltüntetni a state update-elő függvényt, hiszen az nem
változhat. Fontos, hogy a változók, amelyek fel vannak tüntetve a
state-ek property-jei. Hivatkozhatnánk rájuk úgy is, ahogy a kommentben
látszik, de nem jó a teljes state-re hivatkozás, mivel ez akkor is
élesítené a függvényt, ha a state olyan részei változnak, amelyeket a
függvény nem használ.</li>
</ol>
<div class="sourceCode" id="cb46"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="kw">const</span> { <span class="dt">isValid</span><span class="op">:</span> emailIsValid } <span class="op">=</span> emailState<span class="op">;</span></span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a><span class="kw">const</span> { <span class="dt">isValid</span><span class="op">:</span> passwordIsValid } <span class="op">=</span> passwordState<span class="op">;</span></span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" tabindex="-1"></a><span class="fu">useEffect</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb46-5"><a href="#cb46-5" tabindex="-1"></a>  <span class="kw">const</span> identifier <span class="op">=</span> <span class="pp">setTimeout</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb46-6"><a href="#cb46-6" tabindex="-1"></a>    <span class="fu">setFormIsValid</span>(emailIsValid <span class="op">&amp;&amp;</span> passwordIsValid)<span class="op">;</span></span>
<span id="cb46-7"><a href="#cb46-7" tabindex="-1"></a>  }<span class="op">,</span> <span class="dv">500</span>)<span class="op">;</span></span>
<span id="cb46-8"><a href="#cb46-8" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" tabindex="-1"></a>  <span class="cf">return</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb46-10"><a href="#cb46-10" tabindex="-1"></a>    <span class="pp">clearTimeout</span>(identifier)<span class="op">;</span></span>
<span id="cb46-11"><a href="#cb46-11" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb46-12"><a href="#cb46-12" tabindex="-1"></a>}<span class="op">,</span> [emailIsValid<span class="op">,</span> passwordIsValid])<span class="op">;</span></span>
<span id="cb46-13"><a href="#cb46-13" tabindex="-1"></a><span class="co">// also correct [emailState.isValid, passwordState.isValid]</span></span>
<span id="cb46-14"><a href="#cb46-14" tabindex="-1"></a><span class="co">// not correct [emailState, passwordState]</span></span></code></pre></div>
<p>A useEffect-et egyszerűbb formában is használhatjuk: elhagyható a
dependency, ebben az esetben minden újrarenderelésnél újrafut a függvény
(figyelni kell, hogy ne hozzunk létre végtelen ciklust). De megadhatunk
üres array-t is, ebben az esetben a függvény csak az első renderelés
után fut le egyszer.</p>
<p>A useEffect-nek adott függvény viszont nem lehet aszinkron, ezért, ha
mégis aszinkron műveletet akarunk végrehajtani (pl. adatok betöltése
adatbázisból), azt úgy tudjuk megtenni, hogy a useEffect függvényének
testében definiálunk egy aszinkron függvényt, és ezt ugyanott rögtön meg
is hívjuk.</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a><span class="fu">useEffect</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb47-2"><a href="#cb47-2" tabindex="-1"></a>  <span class="kw">const</span> asyncFun <span class="op">=</span> <span class="kw">async</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb47-3"><a href="#cb47-3" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb47-4"><a href="#cb47-4" tabindex="-1"></a>    <span class="co">// e.g. await fetch(&#39;...&#39;)</span></span>
<span id="cb47-5"><a href="#cb47-5" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb47-6"><a href="#cb47-6" tabindex="-1"></a>  </span>
<span id="cb47-7"><a href="#cb47-7" tabindex="-1"></a>  <span class="fu">asyncFun</span>()<span class="op">;</span></span>
<span id="cb47-8"><a href="#cb47-8" tabindex="-1"></a>}<span class="op">,</span> [])</span></code></pre></div>
<p>A React hookok használatának két fő (és egy mellék-) szabálya
van:</p>
<ol style="list-style-type: decimal">
<li>React hookot csak React függvényeken belül használhatunk: komponens
függvények, custom hookok</li>
<li>Csak a react függvények legfelső szintjén használhatjuk: nem
használhatjuk beágyazott függvényekben vagy blokkokban (pl.
if/else)</li>
<li>A useEffect-ben mindent, amit használunk, tüntessünk fel a
dependency részben (kivéve kivételek)</li>
</ol>
</div>
</div>
<div id="inputok-és-formok-kezelése" class="section level2">
<h2>Inputok és formok kezelése</h2>
<div id="onchange-és-debouncing" class="section level3">
<h3>onChange és debouncing</h3>
<hr />
<p>TODO!! *****************************</p>
</div>
<div id="useref" class="section level3">
<h3>useRef</h3>
<p>A useRef hooknak többféle felhasználási módja van. Az egyik az
inputoknál az onChange kiváltása, amivel nem kell minden billentyűleütés
után a state-et frissíteni.</p>
<p>Ehhez importáljuk a <code>useRef</code>-et a <code>react</code>
modulból, majd annyiszor futtatjuk, ahány inputot figyelni akarunk
vele:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="kw">const</span> nameInputRef <span class="op">=</span> <span class="fu">useRef</span>()<span class="op">;</span></span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a><span class="kw">const</span> ageInputRef <span class="op">=</span> <span class="fu">useRef</span>()<span class="op">;</span></span></code></pre></div>
<p>Ezután a létrehozott refeket a komponensekhez társítjuk a
<code>ref</code> prop segítségével:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a><span class="cf">return</span> (</span>
<span id="cb49-2"><a href="#cb49-2" tabindex="-1"></a>  <span class="kw">&lt;form</span> <span class="ot">onSubmit</span><span class="op">=</span><span class="va">{</span>addUserHandler<span class="va">}</span><span class="kw">&gt;</span></span>
<span id="cb49-3"><a href="#cb49-3" tabindex="-1"></a>    <span class="kw">&lt;label</span> <span class="ot">htmlFor</span><span class="op">=</span><span class="st">&quot;username&quot;</span><span class="kw">&gt;</span>Username<span class="kw">&lt;/label&gt;</span></span>
<span id="cb49-4"><a href="#cb49-4" tabindex="-1"></a>    <span class="kw">&lt;input</span> <span class="ot">id</span><span class="op">=</span><span class="st">&quot;username&quot;</span> <span class="ot">type</span><span class="op">=</span><span class="st">&quot;text&quot;</span> <span class="ot">ref</span><span class="op">=</span><span class="va">{</span>nameInputRef<span class="va">}</span> <span class="kw">/&gt;</span></span>
<span id="cb49-5"><a href="#cb49-5" tabindex="-1"></a>    <span class="kw">&lt;label</span> <span class="ot">htmlFor</span><span class="op">=</span><span class="st">&quot;age&quot;</span><span class="kw">&gt;</span>Age<span class="kw">&lt;/label&gt;</span></span>
<span id="cb49-6"><a href="#cb49-6" tabindex="-1"></a>    <span class="kw">&lt;input</span> <span class="ot">id</span><span class="op">=</span><span class="st">&quot;age&quot;</span> <span class="ot">type</span><span class="op">=</span><span class="st">&quot;number&quot;</span> <span class="ot">ref</span><span class="op">=</span><span class="va">{</span>ageInputRef<span class="va">}</span> <span class="kw">/&gt;</span></span>
<span id="cb49-7"><a href="#cb49-7" tabindex="-1"></a>    <span class="fu">&lt;Button</span> <span class="ot">type</span><span class="op">=</span><span class="st">&quot;submit&quot;</span><span class="fu">&gt;</span>Add User<span class="fu">&lt;/Button&gt;</span></span>
<span id="cb49-8"><a href="#cb49-8" tabindex="-1"></a>  <span class="kw">&lt;/form&gt;</span></span>
<span id="cb49-9"><a href="#cb49-9" tabindex="-1"></a>)</span></code></pre></div>
<p>Végül ezek után a megfelelő handler függvényben hozzá tudunk férni a
ref-ek értékeihez. A ref return értéke mindig a DOM objektum, amelyhez
társítottuk, de ennek tulajdonságai hozzáférhetők (így pl. értéke) a
<code>refName.current.value</code> révén.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="kw">const</span> addUserHandler <span class="op">=</span> <span class="bu">event</span> <span class="kw">=&gt;</span> {</span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a>    <span class="bu">event</span><span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a>    <span class="kw">const</span> enteredName <span class="op">=</span> nameInputRef<span class="op">.</span><span class="at">current</span><span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" tabindex="-1"></a>    <span class="kw">const</span> enteredAge <span class="op">=</span> ageInputRef<span class="op">.</span><span class="at">current</span><span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb50-5"><a href="#cb50-5" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb50-6"><a href="#cb50-6" tabindex="-1"></a>  }</span></code></pre></div>
<p>Ennek a megoldásnak ugyanakkor hátránya, hogy nem tudjuk a React-tal
visszaállítani az input mezők értékét. A ref-fel figyelt komponensek
kontrollálatlan komponensek. A state-tel ez lehetséges volt, ha
hozzáadtuk az input value propjához a state-et (contolled component).
Ezt nevezik two-way bindingnak. Lehetséges megoldás (általában
kerülendő, de itt kivételt tehetünk), hogy az adatok továbbítását
követően közvetlenül átírjuk a ref-ek értékét:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a>nameInputRef<span class="op">.</span><span class="at">current</span><span class="op">.</span><span class="at">value</span> <span class="op">=</span> <span class="st">&#39;&#39;</span><span class="op">;</span></span>
<span id="cb51-2"><a href="#cb51-2" tabindex="-1"></a>ageInputRef<span class="op">.</span><span class="at">current</span><span class="op">.</span><span class="at">value</span> <span class="op">=</span> <span class="st">&#39;&#39;</span><span class="op">;</span></span></code></pre></div>
<p>Ha csak olvasni akarunk egy értéket, a ref jó alternatíva. Általában
kevesebb kóddal jár, mint a state.</p>
<p>A ref simán működik a beépített komponenseknél, de saját custom
komponenseknél nem, így ott az egész komponenst, amelyen használni
akarjuk a <code>React.forwardRef()</code> függvény argumentumaként kell
megadni. Ebben az esetben a props mellett második argumentumként
átadhatjuk neki a kapott ref-et.</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="co">// Ahol a custom Input komponenst használjuk</span></span>
<span id="cb52-2"><a href="#cb52-2" tabindex="-1"></a><span class="cf">return</span> (</span>
<span id="cb52-3"><a href="#cb52-3" tabindex="-1"></a>    <span class="kw">&lt;form</span> <span class="ot">className</span><span class="op">=</span><span class="va">{</span>classes<span class="op">.</span><span class="at">form</span><span class="va">}</span> <span class="ot">onSubmit</span><span class="op">=</span><span class="va">{</span>submitHandler<span class="va">}</span><span class="kw">&gt;</span></span>
<span id="cb52-4"><a href="#cb52-4" tabindex="-1"></a>      <span class="fu">&lt;Input</span></span>
<span id="cb52-5"><a href="#cb52-5" tabindex="-1"></a>      </span>
<span id="cb52-6"><a href="#cb52-6" tabindex="-1"></a>        <span class="co">// Korábban a useRef-fel létrehoztunk egy ref-et erre a célra</span></span>
<span id="cb52-7"><a href="#cb52-7" tabindex="-1"></a>        <span class="ot">ref</span><span class="op">=</span><span class="va">{</span>amountInputRef<span class="va">}</span></span>
<span id="cb52-8"><a href="#cb52-8" tabindex="-1"></a>        <span class="ot">label</span><span class="op">=</span><span class="st">&quot;Amount&quot;</span></span>
<span id="cb52-9"><a href="#cb52-9" tabindex="-1"></a>        <span class="ot">input</span><span class="op">=</span><span class="va">{</span>{</span>
<span id="cb52-10"><a href="#cb52-10" tabindex="-1"></a>          <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;amount_&#39;</span> <span class="op">+</span> props<span class="op">.</span><span class="at">id</span><span class="op">,</span></span>
<span id="cb52-11"><a href="#cb52-11" tabindex="-1"></a>          <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;number&#39;</span><span class="op">,</span></span>
<span id="cb52-12"><a href="#cb52-12" tabindex="-1"></a>          <span class="dt">min</span><span class="op">:</span> <span class="st">&#39;1&#39;</span><span class="op">,</span></span>
<span id="cb52-13"><a href="#cb52-13" tabindex="-1"></a>          <span class="dt">max</span><span class="op">:</span> <span class="st">&#39;5&#39;</span><span class="op">,</span></span>
<span id="cb52-14"><a href="#cb52-14" tabindex="-1"></a>          <span class="dt">step</span><span class="op">:</span> <span class="st">&#39;1&#39;</span><span class="op">,</span></span>
<span id="cb52-15"><a href="#cb52-15" tabindex="-1"></a>          <span class="dt">defaultValue</span><span class="op">:</span> <span class="st">&#39;1&#39;</span><span class="op">,</span></span>
<span id="cb52-16"><a href="#cb52-16" tabindex="-1"></a>        }<span class="va">}</span></span>
<span id="cb52-17"><a href="#cb52-17" tabindex="-1"></a>      <span class="fu">/&gt;</span></span>
<span id="cb52-18"><a href="#cb52-18" tabindex="-1"></a>      <span class="kw">&lt;button&gt;</span>+ Add<span class="kw">&lt;/button&gt;</span></span>
<span id="cb52-19"><a href="#cb52-19" tabindex="-1"></a>    <span class="kw">&lt;/form&gt;</span></span>
<span id="cb52-20"><a href="#cb52-20" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb52-21"><a href="#cb52-21" tabindex="-1"></a></span>
<span id="cb52-22"><a href="#cb52-22" tabindex="-1"></a><span class="co">// Input.js-ben</span></span>
<span id="cb52-23"><a href="#cb52-23" tabindex="-1"></a><span class="kw">const</span> Input <span class="op">=</span> React<span class="op">.</span><span class="fu">forwardRef</span>((props<span class="op">,</span> ref) <span class="kw">=&gt;</span> {</span>
<span id="cb52-24"><a href="#cb52-24" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb52-25"><a href="#cb52-25" tabindex="-1"></a>    <span class="kw">&lt;div</span> <span class="ot">className</span><span class="op">=</span><span class="va">{</span>classes<span class="op">.</span><span class="at">input</span><span class="va">}</span><span class="kw">&gt;</span></span>
<span id="cb52-26"><a href="#cb52-26" tabindex="-1"></a>      <span class="kw">&lt;label</span> <span class="ot">htmlFor</span><span class="op">=</span><span class="va">{</span>props<span class="op">.</span><span class="at">input</span><span class="op">.</span><span class="at">id</span><span class="va">}</span><span class="kw">&gt;</span><span class="va">{</span>props<span class="op">.</span><span class="at">label</span><span class="va">}</span><span class="kw">&lt;/label&gt;</span></span>
<span id="cb52-27"><a href="#cb52-27" tabindex="-1"></a>      </span>
<span id="cb52-28"><a href="#cb52-28" tabindex="-1"></a>      // A kapott refet továbbadhatjuk a beépített komponensnek</span>
<span id="cb52-29"><a href="#cb52-29" tabindex="-1"></a>      <span class="kw">&lt;input</span> <span class="ot">ref</span><span class="op">=</span><span class="va">{</span>ref<span class="va">}</span> <span class="va">{</span><span class="op">...</span>props<span class="op">.</span><span class="at">input</span><span class="va">}</span> <span class="kw">/&gt;</span></span>
<span id="cb52-30"><a href="#cb52-30" tabindex="-1"></a>    <span class="kw">&lt;/div&gt;</span></span>
<span id="cb52-31"><a href="#cb52-31" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb52-32"><a href="#cb52-32" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>Ezek után a parent komponensben is hozzáférhetünk a ref
tulajdonságaihoz: <code>amountInputRef.current.value</code>.</p>
</div>
<div id="useimperativehandle" class="section level3">
<h3>useImperativeHandle</h3>
<p>A <code>useRef</code> arra is használható, hogy a komponens bizonyos
összetevőihez a parent komponensnek is hozzáférést biztosítsunk. Így
például egy input komponensnél a komponensre való fókuszálást lehetővé
tegyük az inputot renderelő komponensben (pl. form validationnél a hibás
mezőbe lépjen automatikusan). Ehhez az Input komponenst elláttuk egy ref
prop-pal, amelyhez létrehoztunk egy refet a useRef segítségével:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a></span>
<span id="cb53-2"><a href="#cb53-2" tabindex="-1"></a><span class="co">// In Login.js</span></span>
<span id="cb53-3"><a href="#cb53-3" tabindex="-1"></a><span class="fu">&lt;Input</span></span>
<span id="cb53-4"><a href="#cb53-4" tabindex="-1"></a>  <span class="ot">ref</span><span class="op">=</span><span class="va">{</span>emailInputRef<span class="va">}</span></span>
<span id="cb53-5"><a href="#cb53-5" tabindex="-1"></a>  <span class="ot">type</span><span class="op">=</span><span class="st">&quot;email&quot;</span></span>
<span id="cb53-6"><a href="#cb53-6" tabindex="-1"></a>  <span class="ot">id</span><span class="op">=</span><span class="st">&quot;email&quot;</span></span>
<span id="cb53-7"><a href="#cb53-7" tabindex="-1"></a>  <span class="ot">label</span><span class="op">=</span><span class="st">&quot;E-Mail&quot;</span></span>
<span id="cb53-8"><a href="#cb53-8" tabindex="-1"></a>  <span class="ot">isValid</span><span class="op">=</span><span class="va">{</span>emailIsValid<span class="va">}</span></span>
<span id="cb53-9"><a href="#cb53-9" tabindex="-1"></a>  <span class="ot">value</span><span class="op">=</span><span class="va">{</span>emailState<span class="op">.</span><span class="at">value</span><span class="va">}</span></span>
<span id="cb53-10"><a href="#cb53-10" tabindex="-1"></a>  <span class="ot">onChange</span><span class="op">=</span><span class="va">{</span>emailChangeHandler<span class="va">}</span></span>
<span id="cb53-11"><a href="#cb53-11" tabindex="-1"></a>  <span class="ot">onBlur</span><span class="op">=</span><span class="va">{</span>validateEmailHandler<span class="va">}</span></span>
<span id="cb53-12"><a href="#cb53-12" tabindex="-1"></a><span class="fu">/&gt;</span></span></code></pre></div>
<p>Az Inputot definiáló file-ban importáljuk a
<code>useImperativeHandle</code> hookot, és használjuk, illetve a teljes
komponenst a <code>React.forwardRef</code> függvényben hozzuk létre:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="im">import</span> React<span class="op">,</span> { useRef<span class="op">,</span> useImperativeHandle } <span class="im">from</span> <span class="st">&#39;react&#39;</span><span class="op">;</span></span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" tabindex="-1"></a><span class="co">// forwardRef függvény</span></span>
<span id="cb54-4"><a href="#cb54-4" tabindex="-1"></a><span class="co">// props mellett a ref paraméter teszi lehetővé, hogy a parent komponensben ref propot adjunk a komponensnek</span></span>
<span id="cb54-5"><a href="#cb54-5" tabindex="-1"></a><span class="kw">const</span> Input <span class="op">=</span> React<span class="op">.</span><span class="fu">forwardRef</span>((props<span class="op">,</span> ref) <span class="kw">=&gt;</span> {</span>
<span id="cb54-6"><a href="#cb54-6" tabindex="-1"></a>  <span class="kw">const</span> inputRef <span class="op">=</span> <span class="fu">useRef</span>()<span class="op">;</span></span>
<span id="cb54-7"><a href="#cb54-7" tabindex="-1"></a></span>
<span id="cb54-8"><a href="#cb54-8" tabindex="-1"></a>  <span class="co">// Ez a függvény, amelyet kívülről hívhatóvá akarunk tenni</span></span>
<span id="cb54-9"><a href="#cb54-9" tabindex="-1"></a>  <span class="kw">const</span> activate <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb54-10"><a href="#cb54-10" tabindex="-1"></a>    inputRef<span class="op">.</span><span class="at">current</span><span class="op">.</span><span class="fu">focus</span>()<span class="op">;</span></span>
<span id="cb54-11"><a href="#cb54-11" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb54-12"><a href="#cb54-12" tabindex="-1"></a></span>
<span id="cb54-13"><a href="#cb54-13" tabindex="-1"></a>  <span class="co">// Ez teszi kívülről hívhatóvá a megadott névvel (expose)</span></span>
<span id="cb54-14"><a href="#cb54-14" tabindex="-1"></a>  <span class="fu">useImperativeHandle</span>(ref<span class="op">,</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb54-15"><a href="#cb54-15" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb54-16"><a href="#cb54-16" tabindex="-1"></a>      <span class="dt">focus</span><span class="op">:</span> activate<span class="op">,</span></span>
<span id="cb54-17"><a href="#cb54-17" tabindex="-1"></a>    }<span class="op">;</span></span>
<span id="cb54-18"><a href="#cb54-18" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb54-19"><a href="#cb54-19" tabindex="-1"></a></span>
<span id="cb54-20"><a href="#cb54-20" tabindex="-1"></a>  <span class="co">// Innen a sima JSX kód a reffel kiegészítve, hogy a függvény tudja, mire hivatkozik</span></span>
<span id="cb54-21"><a href="#cb54-21" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb54-22"><a href="#cb54-22" tabindex="-1"></a>    <span class="kw">&lt;div</span></span>
<span id="cb54-23"><a href="#cb54-23" tabindex="-1"></a>      <span class="ot">className</span><span class="op">=</span><span class="va">{</span><span class="vs">`</span><span class="sc">${</span>classes<span class="op">.</span><span class="at">control</span><span class="sc">}</span><span class="vs"> </span><span class="sc">${</span></span>
<span id="cb54-24"><a href="#cb54-24" tabindex="-1"></a>        props<span class="op">.</span><span class="at">isValid</span> <span class="op">===</span> <span class="kw">false</span> <span class="op">?</span> classes<span class="op">.</span><span class="at">invalid</span> <span class="op">:</span> <span class="st">&#39;&#39;</span></span>
<span id="cb54-25"><a href="#cb54-25" tabindex="-1"></a>      <span class="sc">}</span><span class="vs">`</span><span class="va">}</span></span>
<span id="cb54-26"><a href="#cb54-26" tabindex="-1"></a>    <span class="kw">&gt;</span></span>
<span id="cb54-27"><a href="#cb54-27" tabindex="-1"></a>      <span class="kw">&lt;label</span> <span class="ot">htmlFor</span><span class="op">=</span><span class="st">&quot;email&quot;</span><span class="kw">&gt;</span><span class="va">{</span>props<span class="op">.</span><span class="at">label</span><span class="va">}</span><span class="kw">&lt;/label&gt;</span></span>
<span id="cb54-28"><a href="#cb54-28" tabindex="-1"></a>      <span class="kw">&lt;input</span></span>
<span id="cb54-29"><a href="#cb54-29" tabindex="-1"></a>        <span class="ot">ref</span><span class="op">=</span><span class="va">{</span>inputRef<span class="va">}</span></span>
<span id="cb54-30"><a href="#cb54-30" tabindex="-1"></a>        <span class="ot">type</span><span class="op">=</span><span class="va">{</span>props<span class="op">.</span><span class="at">type</span><span class="va">}</span></span>
<span id="cb54-31"><a href="#cb54-31" tabindex="-1"></a>        <span class="ot">id</span><span class="op">=</span><span class="va">{</span>props<span class="op">.</span><span class="at">id</span><span class="va">}</span></span>
<span id="cb54-32"><a href="#cb54-32" tabindex="-1"></a>        <span class="ot">value</span><span class="op">=</span><span class="va">{</span>props<span class="op">.</span><span class="at">value</span><span class="va">}</span></span>
<span id="cb54-33"><a href="#cb54-33" tabindex="-1"></a>        <span class="ot">onChange</span><span class="op">=</span><span class="va">{</span>props<span class="op">.</span><span class="at">onChange</span><span class="va">}</span></span>
<span id="cb54-34"><a href="#cb54-34" tabindex="-1"></a>        <span class="ot">onBlur</span><span class="op">=</span><span class="va">{</span>props<span class="op">.</span><span class="at">onBlur</span><span class="va">}</span></span>
<span id="cb54-35"><a href="#cb54-35" tabindex="-1"></a>      <span class="kw">/&gt;</span></span>
<span id="cb54-36"><a href="#cb54-36" tabindex="-1"></a>    <span class="kw">&lt;/div&gt;</span></span>
<span id="cb54-37"><a href="#cb54-37" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb54-38"><a href="#cb54-38" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb54-39"><a href="#cb54-39" tabindex="-1"></a></span>
<span id="cb54-40"><a href="#cb54-40" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> Input<span class="op">;</span></span></code></pre></div>
<p>Ez a hook ritkán használatos, de néha jól jöhet.</p>
</div>
</div>
<div id="react-router" class="section level2">
<h2>React Router</h2>
<div id="app-számára-elérhetővé-tétel" class="section level3">
<h3>App számára elérhetővé tétel</h3>
<p>A <code>react-router-dom</code> csomagot használjuk, amelynek
jelenleg a 6-os a friss verziója.</p>
</div>
<div id="útvonalak-definiálása" class="section level3">
<h3>Útvonalak definiálása</h3>
<p>Az alapelgondolás, hogy különböző url-ekhez különböző “oldalakat”
nyitunk meg, amelyek alapvetően sima React komponensek, de szokás a
különböző útvonalakhoz kapcsolódó komponenseket külön mappában (pl.
<code>pages</code>, <code>routes</code> vagy <code>screens</code>)
tárolni, és a <code>components</code> mappát a kisebb alkotóelemeknek
meghagyni.</p>
<p>Ezeket az útvonalakat többféleképpen definiálhatjuk.</p>
<div id="createbrowserrouter-függvénnyel" class="section level4">
<h4>createBrowserRouter függvénnyel</h4>
<p>A tutorial alapján ez most az útvonalak létrehozásának preferált
módja. Ez azért is fontos, mert sok új funkció csak ennek (vagy hasonló
módoknak) a használatával érhető el.</p>
<p>A <code>createBrowserRouter</code> paramétereiként megadhatjuk a
különböző útvonalakat, és az ezekhez renderelendő komponenseket, és
ennek return értéke egy router objektum lesz. Az alkalmazást magát a
<code>&lt;RouterProvider /&gt;</code> komponenssel rendereljük, amelynek
a <code>router</code> propja az előbb létrehozott router objektumot
kapja. Ez lesz az egész App komponens.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a><span class="co">// App.js</span></span>
<span id="cb55-2"><a href="#cb55-2" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" tabindex="-1"></a><span class="im">import</span> { createBrowserRouter<span class="op">,</span> RouterProvider } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb55-4"><a href="#cb55-4" tabindex="-1"></a></span>
<span id="cb55-5"><a href="#cb55-5" tabindex="-1"></a><span class="im">import</span> HomePage <span class="im">from</span> <span class="st">&#39;./pages/Home&#39;</span><span class="op">;</span></span>
<span id="cb55-6"><a href="#cb55-6" tabindex="-1"></a><span class="im">import</span> ProductsPage <span class="im">from</span> <span class="st">&#39;./pages/Products&#39;</span><span class="op">;</span></span>
<span id="cb55-7"><a href="#cb55-7" tabindex="-1"></a></span>
<span id="cb55-8"><a href="#cb55-8" tabindex="-1"></a><span class="kw">const</span> router <span class="op">=</span> <span class="fu">createBrowserRouter</span>([</span>
<span id="cb55-9"><a href="#cb55-9" tabindex="-1"></a>  { <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/&#39;</span><span class="op">,</span> <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;HomePage</span> <span class="fu">/&gt;</span> }<span class="op">,</span></span>
<span id="cb55-10"><a href="#cb55-10" tabindex="-1"></a>  { <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/products&#39;</span><span class="op">,</span> <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;ProductsPage</span> <span class="fu">/&gt;</span> }<span class="op">,</span></span>
<span id="cb55-11"><a href="#cb55-11" tabindex="-1"></a>])<span class="op">;</span></span>
<span id="cb55-12"><a href="#cb55-12" tabindex="-1"></a></span>
<span id="cb55-13"><a href="#cb55-13" tabindex="-1"></a><span class="kw">function</span> <span class="fu">App</span>() {</span>
<span id="cb55-14"><a href="#cb55-14" tabindex="-1"></a>  <span class="cf">return </span><span class="fu">&lt;RouterProvider</span> <span class="ot">router</span><span class="op">=</span><span class="va">{</span>router<span class="va">}</span> <span class="fu">/&gt;</span><span class="op">;</span></span>
<span id="cb55-15"><a href="#cb55-15" tabindex="-1"></a>}</span>
<span id="cb55-16"><a href="#cb55-16" tabindex="-1"></a></span>
<span id="cb55-17"><a href="#cb55-17" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> App<span class="op">;</span></span></code></pre></div>
</div>
<div id="createroutesfromelements-függvénnyel" class="section level4">
<h4>createRoutesFromElements függvénnyel</h4>
<p>Az útvonalakat a <code>createRoutesFromElements</code> függvénnyel is
definiálhatjuk. Ez arra is hasznos lehet, ha a korábbi módnak
megfelelően a <code>Route</code> komponensekkel adtuk meg az
útvonalakat, ezekből könnyen BrowserRouter-t készíthetünk a
<code>createBrowserRouter</code>-rel, és kihasználhatjuk az új data
API-k funkcióit.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a><span class="co">// App.js</span></span>
<span id="cb56-2"><a href="#cb56-2" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" tabindex="-1"></a><span class="im">import</span> {</span>
<span id="cb56-4"><a href="#cb56-4" tabindex="-1"></a>  createBrowserRouter<span class="op">,</span></span>
<span id="cb56-5"><a href="#cb56-5" tabindex="-1"></a>  createRoutesFromElements<span class="op">,</span></span>
<span id="cb56-6"><a href="#cb56-6" tabindex="-1"></a>  RouterProvider<span class="op">,</span></span>
<span id="cb56-7"><a href="#cb56-7" tabindex="-1"></a>  Route</span>
<span id="cb56-8"><a href="#cb56-8" tabindex="-1"></a>} <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb56-9"><a href="#cb56-9" tabindex="-1"></a></span>
<span id="cb56-10"><a href="#cb56-10" tabindex="-1"></a><span class="im">import</span> HomePage <span class="im">from</span> <span class="st">&#39;./pages/Home&#39;</span><span class="op">;</span></span>
<span id="cb56-11"><a href="#cb56-11" tabindex="-1"></a><span class="im">import</span> ProductsPage <span class="im">from</span> <span class="st">&#39;./pages/Products&#39;</span><span class="op">;</span></span>
<span id="cb56-12"><a href="#cb56-12" tabindex="-1"></a></span>
<span id="cb56-13"><a href="#cb56-13" tabindex="-1"></a><span class="kw">const</span> routeDefinitions <span class="op">=</span> <span class="fu">createRoutesFromElements</span>(</span>
<span id="cb56-14"><a href="#cb56-14" tabindex="-1"></a>  <span class="fu">&lt;Route&gt;</span></span>
<span id="cb56-15"><a href="#cb56-15" tabindex="-1"></a>    <span class="fu">&lt;Route</span> <span class="ot">path</span><span class="op">=</span><span class="st">&quot;/&quot;</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;HomePage</span> <span class="fu">/&gt;</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb56-16"><a href="#cb56-16" tabindex="-1"></a>    <span class="fu">&lt;Route</span> <span class="ot">path</span><span class="op">=</span><span class="st">&quot;/products&quot;</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;ProductsPage</span> <span class="fu">/&gt;</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb56-17"><a href="#cb56-17" tabindex="-1"></a>  <span class="fu">&lt;/Route&gt;</span></span>
<span id="cb56-18"><a href="#cb56-18" tabindex="-1"></a>)<span class="op">;</span></span>
<span id="cb56-19"><a href="#cb56-19" tabindex="-1"></a></span>
<span id="cb56-20"><a href="#cb56-20" tabindex="-1"></a><span class="kw">const</span> router <span class="op">=</span> <span class="fu">createBrowserRouter</span>(routeDefinitions)<span class="op">;</span></span>
<span id="cb56-21"><a href="#cb56-21" tabindex="-1"></a></span>
<span id="cb56-22"><a href="#cb56-22" tabindex="-1"></a><span class="kw">function</span> <span class="fu">App</span>() {</span>
<span id="cb56-23"><a href="#cb56-23" tabindex="-1"></a>  <span class="cf">return </span><span class="fu">&lt;RouterProvider</span> <span class="ot">router</span><span class="op">=</span><span class="va">{</span>router<span class="va">}</span> <span class="fu">/&gt;</span><span class="op">;</span></span>
<span id="cb56-24"><a href="#cb56-24" tabindex="-1"></a>}</span>
<span id="cb56-25"><a href="#cb56-25" tabindex="-1"></a></span>
<span id="cb56-26"><a href="#cb56-26" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> App<span class="op">;</span></span></code></pre></div>
</div>
<div id="browserrouter-komponenssel" class="section level4">
<h4>BrowserRouter komponenssel</h4>
<p>A ReactRouter 6.4-es verziójáig ez volt az útvonalak definiálásának
egyedüli módja.</p>
<p>Ahhoz, hogy a router működjön, a fő file-ban (index.js) importálni
kell a <code>BrowserRouter</code> komponenst (nevesített importtal), és
a renderelés során a render metódusban az App-ot ebbe kell csomagolni,
mert ezen belül fognak működni a router csomag funkciói.</p>
<p>Az útvonalak definiálásához a <code>Routes</code> és
<code>Route</code> komponenseket importáljuk, és ezeket használjuk az
egyes oldalak rendereléséhez. Ez történhet az <code>App.js</code>
file-ban, de használhatjuk valamelyik komponensben is.</p>
<p>Az alkalmazás router által kezelt részét a <code>Routes</code>
komponensbe csomagoljuk.</p>
<p>Ebben a <code>Route</code> komponenst használjuk mindegyik
útvonalhoz. Az 5-ös verzióban ebbe csomagoltuk a komponenst, a 6-os
verzióban viszont az <code>element</code> prop-nak adjuk az adott oldal
komponenst. A Route komponens <code>path</code> propjával adhatjuk meg,
mely útvonal esetén szeretnénk ezt a komponenst renderelni.</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a><span class="co">// index.js</span></span>
<span id="cb57-2"><a href="#cb57-2" tabindex="-1"></a><span class="im">import</span> React <span class="im">from</span> <span class="st">&#39;react&#39;</span><span class="op">;</span></span>
<span id="cb57-3"><a href="#cb57-3" tabindex="-1"></a><span class="im">import</span> ReactDOM <span class="im">from</span> <span class="st">&#39;react-dom/client&#39;</span><span class="op">;</span></span>
<span id="cb57-4"><a href="#cb57-4" tabindex="-1"></a><span class="im">import</span> { BrowserRouter } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb57-5"><a href="#cb57-5" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" tabindex="-1"></a><span class="im">import</span> App <span class="im">from</span> <span class="st">&#39;./App&#39;</span><span class="op">;</span></span>
<span id="cb57-7"><a href="#cb57-7" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" tabindex="-1"></a><span class="kw">const</span> <span class="bu">root</span> <span class="op">=</span> ReactDOM<span class="op">.</span><span class="fu">createRoot</span>(<span class="bu">document</span><span class="op">.</span><span class="fu">getElementById</span>(<span class="st">&#39;root&#39;</span>))<span class="op">;</span></span>
<span id="cb57-9"><a href="#cb57-9" tabindex="-1"></a><span class="bu">root</span><span class="op">.</span><span class="fu">render</span>(</span>
<span id="cb57-10"><a href="#cb57-10" tabindex="-1"></a>  <span class="fu">&lt;React.StrictMode&gt;</span></span>
<span id="cb57-11"><a href="#cb57-11" tabindex="-1"></a>    <span class="fu">&lt;BrowserRouter&gt;</span></span>
<span id="cb57-12"><a href="#cb57-12" tabindex="-1"></a>      <span class="fu">&lt;App</span> <span class="fu">/&gt;</span></span>
<span id="cb57-13"><a href="#cb57-13" tabindex="-1"></a>    <span class="fu">&lt;/BrowserRouter&gt;</span></span>
<span id="cb57-14"><a href="#cb57-14" tabindex="-1"></a>  <span class="fu">&lt;/React.StrictMode&gt;</span></span>
<span id="cb57-15"><a href="#cb57-15" tabindex="-1"></a>)<span class="op">;</span></span>
<span id="cb57-16"><a href="#cb57-16" tabindex="-1"></a></span>
<span id="cb57-17"><a href="#cb57-17" tabindex="-1"></a><span class="co">// App.js</span></span>
<span id="cb57-18"><a href="#cb57-18" tabindex="-1"></a><span class="im">import</span> { Routes<span class="op">,</span> Route } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb57-19"><a href="#cb57-19" tabindex="-1"></a></span>
<span id="cb57-20"><a href="#cb57-20" tabindex="-1"></a><span class="im">import</span> Home <span class="im">from</span> <span class="st">&#39;./routes/home/home.component&#39;</span><span class="op">;</span></span>
<span id="cb57-21"><a href="#cb57-21" tabindex="-1"></a><span class="im">import</span> Shop <span class="im">from</span> <span class="st">&#39;./routes/shop/shop.component&#39;</span><span class="op">;</span></span>
<span id="cb57-22"><a href="#cb57-22" tabindex="-1"></a></span>
<span id="cb57-23"><a href="#cb57-23" tabindex="-1"></a><span class="kw">const</span> App <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb57-24"><a href="#cb57-24" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb57-25"><a href="#cb57-25" tabindex="-1"></a>    <span class="fu">&lt;Routes&gt;</span></span>
<span id="cb57-26"><a href="#cb57-26" tabindex="-1"></a>      <span class="fu">&lt;Route</span> <span class="ot">path</span><span class="op">=</span><span class="st">&quot;/&quot;</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;Home</span> <span class="fu">/&gt;</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb57-27"><a href="#cb57-27" tabindex="-1"></a>      <span class="fu">&lt;Route</span> <span class="ot">path</span><span class="op">=</span><span class="st">&quot;/shop&quot;</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;Shop</span> <span class="fu">/&gt;</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb57-28"><a href="#cb57-28" tabindex="-1"></a>    <span class="fu">&lt;/Routes&gt;</span></span>
<span id="cb57-29"><a href="#cb57-29" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb57-30"><a href="#cb57-30" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb57-31"><a href="#cb57-31" tabindex="-1"></a></span>
<span id="cb57-32"><a href="#cb57-32" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> App<span class="op">;</span></span></code></pre></div>
</div>
<div id="egymásba-ágyazódó-útvonalak" class="section level4">
<h4>Egymásba ágyazódó útvonalak</h4>
<p>A React Router lehetővé teszi az egymásba ágyazódó útvonalakat.</p>
<p>A <code>createBrowserRouter</code> függvény használatánál a
<code>children</code> property-t használhatjuk, és ennek értékei a
beágyazódó route-ok.</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="kw">const</span> router <span class="op">=</span> <span class="fu">createBrowserRouter</span>([</span>
<span id="cb58-2"><a href="#cb58-2" tabindex="-1"></a>  {</span>
<span id="cb58-3"><a href="#cb58-3" tabindex="-1"></a>    <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/&#39;</span><span class="op">,</span></span>
<span id="cb58-4"><a href="#cb58-4" tabindex="-1"></a>    <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;RootLayout</span> <span class="fu">/&gt;</span><span class="op">,</span></span>
<span id="cb58-5"><a href="#cb58-5" tabindex="-1"></a>    <span class="dt">children</span><span class="op">:</span> [</span>
<span id="cb58-6"><a href="#cb58-6" tabindex="-1"></a>      { <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/&#39;</span><span class="op">,</span> <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;HomePage</span> <span class="fu">/&gt;</span> }<span class="op">,</span></span>
<span id="cb58-7"><a href="#cb58-7" tabindex="-1"></a>      { <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/products&#39;</span><span class="op">,</span> <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;ProductsPage</span> <span class="fu">/&gt;</span> }<span class="op">,</span></span>
<span id="cb58-8"><a href="#cb58-8" tabindex="-1"></a>    ]<span class="op">,</span></span>
<span id="cb58-9"><a href="#cb58-9" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb58-10"><a href="#cb58-10" tabindex="-1"></a>])<span class="op">;</span></span></code></pre></div>
<p>A <code>Route</code> komponensnél, ha begágyazódó útvonalat
szeretnénk, a komponenst rendes nyitó és zárótaggel hozzuk létre, és
ezen belül is használhatjuk a Route komponenst. Az útvonalat érdemes
relatívan megadni a komponens útvonalához képest, tehát nem
<code>/sub-route</code> hanem <code>sub-route</code> formában, mert így,
ha változik a szülő elérési útvonala, a relatív útvonalakon nem kell
változtatni.</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="kw">const</span> App <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a>    <span class="fu">&lt;Routes&gt;</span></span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a>      <span class="fu">&lt;Route</span> <span class="ot">path</span><span class="op">=</span><span class="st">&quot;/&quot;</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;Navigation</span> <span class="fu">/&gt;</span><span class="va">}</span><span class="fu">&gt;</span></span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a>        <span class="fu">&lt;Route</span> <span class="ot">index</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;Home</span> <span class="fu">/&gt;</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a>        <span class="fu">&lt;Route</span> <span class="ot">path</span><span class="op">=</span><span class="st">&quot;shop/*&quot;</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;Shop</span> <span class="fu">/&gt;</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb59-7"><a href="#cb59-7" tabindex="-1"></a>        <span class="fu">&lt;Route</span> <span class="ot">path</span><span class="op">=</span><span class="st">&quot;auth&quot;</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;Authentication</span> <span class="fu">/&gt;</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb59-8"><a href="#cb59-8" tabindex="-1"></a>        <span class="fu">&lt;Route</span> <span class="ot">path</span><span class="op">=</span><span class="st">&quot;checkout&quot;</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;Checkout</span> <span class="fu">/&gt;</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb59-9"><a href="#cb59-9" tabindex="-1"></a>      <span class="fu">&lt;/Route&gt;</span></span>
<span id="cb59-10"><a href="#cb59-10" tabindex="-1"></a>    <span class="fu">&lt;/Routes&gt;</span></span>
<span id="cb59-11"><a href="#cb59-11" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb59-12"><a href="#cb59-12" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p>Ilyenkor azonban alapértelemezett esetben a szülő komponens is
renderelődik. A gyermek komponenst pedig meg kell adni, hová szeretnénk
renderelni a szülőn belül. Ehhez az <code>Outlet</code> komponenst kell
használni a szülő JSX kódjában. Ezt felhasználva lehetséges, hogy csak
az oldal bizonyos részeit módosítsuk a route függvényében.</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="kw">const</span> Navigation <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb60-5"><a href="#cb60-5" tabindex="-1"></a>    <span class="fu">&lt;Fragment&gt;</span></span>
<span id="cb60-6"><a href="#cb60-6" tabindex="-1"></a>      <span class="fu">&lt;NavigationContainer&gt;</span></span>
<span id="cb60-7"><a href="#cb60-7" tabindex="-1"></a>        <span class="va">{</span><span class="co">// ...}</span></span>
<span id="cb60-8"><a href="#cb60-8" tabindex="-1"></a>      <span class="op">&lt;</span>/NavigationContainer&gt;</span>
<span id="cb60-9"><a href="#cb60-9" tabindex="-1"></a>      <span class="fu">&lt;Outlet</span> <span class="fu">/&gt;</span></span>
<span id="cb60-10"><a href="#cb60-10" tabindex="-1"></a>    <span class="fu">&lt;/Fragment&gt;</span></span>
<span id="cb60-11"><a href="#cb60-11" tabindex="-1"></a>  );</span>
<span id="cb60-12"><a href="#cb60-12" tabindex="-1"></a>};</span></code></pre></div>
<p>Például ezzel is elérhető, hogy a navigáció több oldalon is elérhető
legyen. Ha a szülőként megadott útvonalon valamelyik gyermeket is
renderelni szeretnénk, akkor ennek path helyett az index property-t is
megadhatjuk simán <code>index</code> formában, vagy
<code>index: true</code> formában, ha a createBrowserRouter-t
használjuk. Ha útvonalat akarunk megadni, megadhatjuk a
<code>path=''</code> vagy <code>path: ''</code> relatív útvonalat
is.</p>
<p>Ha attól függően, hogy csak a fő útvonalra (pl. <code>/shop</code>)
vagy azon belül valamelyik alútvonalra megyünk
(<code>/shop/shoes</code>), az útvonalakat az adott route-on is
megadhatjuk. Pl. az <code>App.js</code> file-ban létrehozzuk a
<code>shop/*</code> útvonalhoz tartozó <code>Route</code> komponenst, és
ezen a <code>Shop</code> route komponenst rendereljük. Ennek tartalma
pedit egy újabb <code>Routes</code> komponensbe ágyazott
<code>Route</code>-ok: külön az <code>index</code> útvonalra, és külön
az egyes alútvonalakra, akár dinamikusan: pl. <code>:category</code>.
Itt a <code>path</code> propot az adott oldal url-jéhez képest kell csak
megadni, tehát pl. ebben a példában a <code>/shop</code> részt
elhagyjuk.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a><span class="im">import</span> { Routes<span class="op">,</span> Route } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb61-2"><a href="#cb61-2" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" tabindex="-1"></a><span class="im">import</span> CategoriesPreview <span class="im">from</span> <span class="st">&#39;../categories-preview/categories-preview.component&#39;</span><span class="op">;</span></span>
<span id="cb61-4"><a href="#cb61-4" tabindex="-1"></a><span class="im">import</span> Category <span class="im">from</span> <span class="st">&#39;../category/category.component&#39;</span><span class="op">;</span></span>
<span id="cb61-5"><a href="#cb61-5" tabindex="-1"></a></span>
<span id="cb61-6"><a href="#cb61-6" tabindex="-1"></a><span class="kw">const</span> Shop <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb61-7"><a href="#cb61-7" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb61-8"><a href="#cb61-8" tabindex="-1"></a>    <span class="fu">&lt;Routes&gt;</span></span>
<span id="cb61-9"><a href="#cb61-9" tabindex="-1"></a>      <span class="fu">&lt;Route</span> <span class="ot">index</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;CategoriesPreview</span> <span class="fu">/&gt;</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb61-10"><a href="#cb61-10" tabindex="-1"></a>      <span class="fu">&lt;Route</span> <span class="ot">path</span><span class="op">=</span><span class="st">&quot;:category&quot;</span> <span class="ot">element</span><span class="op">=</span><span class="va">{</span><span class="fu">&lt;Category</span> <span class="fu">/&gt;</span><span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb61-11"><a href="#cb61-11" tabindex="-1"></a>    <span class="fu">&lt;/Routes&gt;</span></span>
<span id="cb61-12"><a href="#cb61-12" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb61-13"><a href="#cb61-13" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb61-14"><a href="#cb61-14" tabindex="-1"></a></span>
<span id="cb61-15"><a href="#cb61-15" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> Shop<span class="op">;</span></span></code></pre></div>
<p>Ez azért kell, mert a Route-hoz meg kell adni az <code>element</code>
proppal, mit rendereljen. Ha azt szeretnénk, hogy a fő route komponensét
ne renderelje az alútvonalakon, azt így tudjuk megoldani.</p>
<p>Példaként ld. a crwn-clothin projektben a shop route-ot.</p>
</div>
<div id="error-element" class="section level4">
<h4>Error Element</h4>
<p>A React Routerrel kezelhetjük a nem definiált útvonalakat is:
létrehozhatunk egy olyan oldalt, amelyet akkor nyit meg, ha a megadott
url-hez nincs Route definiálva. Ilyenkor a program automatikusan 404-es
hibát dob, és ezt a komponenst rendereli. Ezt az útvonalak definiálása
során az <code>errorElement</code> property-vel tudjuk megadni azokhoz a
szülő route-okhoz, amelyekhez ezt szeretnénk renderelni:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a><span class="kw">const</span> router <span class="op">=</span> <span class="fu">createBrowserRouter</span>([</span>
<span id="cb62-2"><a href="#cb62-2" tabindex="-1"></a>  {</span>
<span id="cb62-3"><a href="#cb62-3" tabindex="-1"></a>    <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/&#39;</span><span class="op">,</span></span>
<span id="cb62-4"><a href="#cb62-4" tabindex="-1"></a>    <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;RootLayout</span> <span class="fu">/&gt;</span><span class="op">,</span></span>
<span id="cb62-5"><a href="#cb62-5" tabindex="-1"></a>    <span class="dt">errorElement</span><span class="op">: </span><span class="fu">&lt;ErrorPage</span> <span class="fu">/&gt;</span><span class="op">;</span></span>
<span id="cb62-6"><a href="#cb62-6" tabindex="-1"></a>    <span class="dt">children</span><span class="op">:</span> [</span>
<span id="cb62-7"><a href="#cb62-7" tabindex="-1"></a>      { <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/&#39;</span><span class="op">,</span> <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;HomePage</span> <span class="fu">/&gt;</span> }<span class="op">,</span></span>
<span id="cb62-8"><a href="#cb62-8" tabindex="-1"></a>      { <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/products&#39;</span><span class="op">,</span> <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;ProductsPage</span> <span class="fu">/&gt;</span> }<span class="op">,</span></span>
<span id="cb62-9"><a href="#cb62-9" tabindex="-1"></a>    ]<span class="op">,</span></span>
<span id="cb62-10"><a href="#cb62-10" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb62-11"><a href="#cb62-11" tabindex="-1"></a>])<span class="op">;</span></span></code></pre></div>
<p>ErrorElementet a beágyazódó útvonalakhoz is megadhatunk.</p>
</div>
</div>
<div id="navigálás" class="section level3">
<h3>Navigálás</h3>
<div id="navigálás-link-komponensekkel" class="section level4">
<h4>Navigálás Link komponensekkel</h4>
<p>Az oldalon belüli navigációhoz importáljuk a <code>Link</code> vagy
<code>NavLink</code> komponenst, amellyel kiválthatjuk a hagyományos a
elemeket (ezek új http requestet küldenének, és elveszítenénk a
state-et). Ezek <code>href</code> helyett <code>to</code> proport
kapnak. A <code>NavLink</code> előnye, hogy ezzel létrehozhatunk egy
aktív osztálynevet az éppen aktív elemnek (pl. megfelelő menuelem).
Ehhez a <code>className</code> propnak egy függvényt adunk értékül,
amely hozzáfér egy objektumhoz az <code>isActive</code> property-vel,
amely alapján hozzárendelhetünk CSS osztályokat. Ezeket a szokásos módon
tudjuk kezelni a css-ben.</p>
<p>Arra viszont figyelni kell, hogy akkor is aktívnak gondolhat egy
linket, ha az adott útvonal alá tartozó url-en vagyunk: pl. a
<code>/</code> útvonal mindig aktív lenne. Ilyenkor hozzáadhatjuk az
<code>end</code> propot, és így csak a pontos egyezéseket nézi.</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a><span class="fu">&lt;NavLink</span> </span>
<span id="cb63-2"><a href="#cb63-2" tabindex="-1"></a>  <span class="ot">to</span><span class="op">=</span><span class="st">&quot;/&quot;</span> </span>
<span id="cb63-3"><a href="#cb63-3" tabindex="-1"></a>  <span class="ot">className</span><span class="op">=</span><span class="va">{</span>({ isActive }) <span class="kw">=&gt;</span> </span>
<span id="cb63-4"><a href="#cb63-4" tabindex="-1"></a>      isActive <span class="op">?</span> classes<span class="op">.</span><span class="at">active</span> <span class="op">:</span> <span class="kw">undefined</span> </span>
<span id="cb63-5"><a href="#cb63-5" tabindex="-1"></a>    <span class="va">}</span></span>
<span id="cb63-6"><a href="#cb63-6" tabindex="-1"></a>    <span class="ot">end</span></span>
<span id="cb63-7"><a href="#cb63-7" tabindex="-1"></a>  <span class="fu">&gt;</span></span>
<span id="cb63-8"><a href="#cb63-8" tabindex="-1"></a>    Home</span>
<span id="cb63-9"><a href="#cb63-9" tabindex="-1"></a>  <span class="fu">&lt;/NavLink&gt;</span></span>
<span id="cb63-10"><a href="#cb63-10" tabindex="-1"></a><span class="fu">&lt;NavLink</span> </span>
<span id="cb63-11"><a href="#cb63-11" tabindex="-1"></a>  <span class="ot">to</span><span class="op">=</span><span class="st">&quot;/products&quot;</span> </span>
<span id="cb63-12"><a href="#cb63-12" tabindex="-1"></a>  <span class="ot">className</span><span class="op">=</span><span class="va">{</span>({ isActive }) <span class="kw">=&gt;</span> </span>
<span id="cb63-13"><a href="#cb63-13" tabindex="-1"></a>      isActive <span class="op">?</span> classes<span class="op">.</span><span class="at">active</span> <span class="op">:</span> <span class="kw">undefined</span> </span>
<span id="cb63-14"><a href="#cb63-14" tabindex="-1"></a>    <span class="va">}</span></span>
<span id="cb63-15"><a href="#cb63-15" tabindex="-1"></a>  <span class="fu">&gt;</span></span>
<span id="cb63-16"><a href="#cb63-16" tabindex="-1"></a>    Products</span>
<span id="cb63-17"><a href="#cb63-17" tabindex="-1"></a>  <span class="fu">&lt;/NavLink&gt;</span></span></code></pre></div>
</div>
<div id="programmatikus-navigálás" class="section level4">
<h4>Programmatikus navigálás</h4>
<p>Programmatikus navigálás: React Routerben ehhez is van egy hook:
<code>useNavigate</code>, amelyet ha hívunk, egy <code>navigate</code>
függvényt kapunk, amelyet használhatunk pl. a handler függvényeinkben.
Ennek megadhatjuk azt az útvonalat, ahová navigálni szeretnénk pl. egy
időzítő lejártakor vagy egy form adatainak elküldése után.</p>
<p>Szintén hasznos a <code>redirect</code> függvény, amely lehetővé
teszi, hogy pl. valamilyen tevékenység végeztével (pl. form elküldése)
átirányítsunk egy másik url-re. Ezt használhatjuk olyan esetekben is,
amikor a <code>useNavigate</code> hookok nem: pl. action függvényekben,
amelyek nem komponensek.</p>
</div>
</div>
<div id="dinamikus-url-ek" class="section level3">
<h3>Dinamikus url-ek</h3>
<p>A route-oknak dinamikus részei is lehetnek, amelyeket a szokásos (ld.
Node.js, Vue.js) módon adhatunk meg (akár egymás után többet is):
<code>/products/:productId</code> vagy
<code>/products/:category/:subcat/:prodId</code></p>
<p>A dinamikus stringeket (pl. Linkek <code>to</code> propjához)
legegyszerűbben template literallal vagy relatív útvonal esetén
egyszerűen a dinamikus részt értékként megadva tudjuk létrehozni.</p>
<p>Ahhoz, hogy a dinamikus részekhez hozzáférjünk, a feltételesen
renderelt komponensben (pl. ProductDetail.js) a <code>useParams</code>
hookot használjuk a <code>react-router-dom</code> csomagból. Ezt a
komponens felső szintjén hívhatjuk, és a return értéke egy objektum,
amelyben az egyes paraméterek találhatók key-value párokban.</p>
</div>
<div id="abszolút-és-relatív-útvonalak" class="section level3">
<h3>Abszolút és relatív útvonalak</h3>
<p>A route definíciókban és a linkek to propjain abszolút és relatív
útvonalakat is megadhatunk. Az abszolút útvonalak <code>/</code>-rel
kezdődnek: pl. <code>/products/:productId</code> és ezek rögtön a domain
után kerülnek, és így épül fel az url.</p>
<p>A relatív útvonalaknál elhagyjuk a <code>/</code> jelet az elejéről,
és ilyenkor a megadott útvonal az aktuális útvonal végére kerül.
Használhatjuk a <code>..</code> útvonalat is, hogy egy szinten felfelé
lépjünk (pl. Vissza gomb), de ebben az esetben arra figyelni kell, hogy
ez alapértelmezett esetben nem az útvonalhoz képest értelmezendő, hanem
a route definíciókhoz képest: ezekben lét felfelé.</p>
<p>Pl. ha a <code>products</code> és a <code>products/:productId</code>
route-ok egymás testvérei, nem pedig az utóbbi az előbbi gyermeke, akkor
mindkettőről a szülő route-ra lép vissza.</p>
<p>Ha ezt meg szeretnénk változtatni, és a path-ban szeretnénk egy
szinten feljebb lépni, azt a Link-hez adott <code>relative="path"</code>
proppal tudjuk megtenni. Az alapértelmezett
<code>relative="route"</code>.</p>
</div>
<div id="loaderek" class="section level3">
<h3>Loaderek</h3>
<p>A loaderek lehetővé teszik, hogy az oldal megnyitása előtt futtassunk
olyan függvényt, amely return értékéhez az oldal hozzáfér. Ez
használható pl. az oldalhoz szükséges adatoknak adatbázisból való
betöltésére. Ehhez az adott route definíciójához hozzáadjuk a loader
property-t, amelynek értéke az adott függvény, ami lehet aszinkron is.
Ezt jó gyakorlat az adott route-hoz tartozó oldal komponens file-jában
létrehozni és exportálni, így a route-okat deklaráló file is
áttekinthető marad. Ebben csak a függvény referenciáját adjuk a loader
property-nek.</p>
<p>A loader függvény az oldalra való navigálás megkezdése után fut le,
és return értéke hozzáférhető az adott oldal komponensben és az összes
gyermekében: oldal komponensekben és sima komponensekben egyaránt, a
<code>useLoaderData</code> hook segítségével, amelynek a return értéke a
loader függvény return értéke.</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="co">// App.js</span></span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a><span class="co">// import ...</span></span>
<span id="cb64-3"><a href="#cb64-3" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" tabindex="-1"></a><span class="kw">const</span> router <span class="op">=</span> <span class="fu">createBrowserRouter</span>([</span>
<span id="cb64-5"><a href="#cb64-5" tabindex="-1"></a>  {</span>
<span id="cb64-6"><a href="#cb64-6" tabindex="-1"></a>    <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/&#39;</span><span class="op">,</span></span>
<span id="cb64-7"><a href="#cb64-7" tabindex="-1"></a>    <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;RootLayout</span> <span class="fu">/&gt;</span><span class="op">,</span></span>
<span id="cb64-8"><a href="#cb64-8" tabindex="-1"></a>    <span class="dt">children</span><span class="op">:</span> [</span>
<span id="cb64-9"><a href="#cb64-9" tabindex="-1"></a>      { <span class="dt">index</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span> <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;HomePage</span> <span class="fu">/&gt;</span> }<span class="op">,</span></span>
<span id="cb64-10"><a href="#cb64-10" tabindex="-1"></a>      {</span>
<span id="cb64-11"><a href="#cb64-11" tabindex="-1"></a>        <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;events&#39;</span><span class="op">,</span></span>
<span id="cb64-12"><a href="#cb64-12" tabindex="-1"></a>        <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;EventsLayout</span> <span class="fu">/&gt;</span><span class="op">,</span></span>
<span id="cb64-13"><a href="#cb64-13" tabindex="-1"></a>        <span class="dt">children</span><span class="op">:</span> [</span>
<span id="cb64-14"><a href="#cb64-14" tabindex="-1"></a>          {</span>
<span id="cb64-15"><a href="#cb64-15" tabindex="-1"></a>            <span class="dt">index</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb64-16"><a href="#cb64-16" tabindex="-1"></a>            <span class="dt">element</span><span class="op">: </span><span class="fu">&lt;EventsPage</span> <span class="fu">/&gt;</span><span class="op">,</span></span>
<span id="cb64-17"><a href="#cb64-17" tabindex="-1"></a>            <span class="dt">loader</span><span class="op">:</span> eventsLoader<span class="op">,</span></span>
<span id="cb64-18"><a href="#cb64-18" tabindex="-1"></a>          }<span class="op">,</span></span>
<span id="cb64-19"><a href="#cb64-19" tabindex="-1"></a>          <span class="co">// other routes</span></span>
<span id="cb64-20"><a href="#cb64-20" tabindex="-1"></a>        ]<span class="op">,</span></span>
<span id="cb64-21"><a href="#cb64-21" tabindex="-1"></a>      }<span class="op">,</span></span>
<span id="cb64-22"><a href="#cb64-22" tabindex="-1"></a>    ]<span class="op">,</span></span>
<span id="cb64-23"><a href="#cb64-23" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb64-24"><a href="#cb64-24" tabindex="-1"></a>])<span class="op">;</span></span>
<span id="cb64-25"><a href="#cb64-25" tabindex="-1"></a></span>
<span id="cb64-26"><a href="#cb64-26" tabindex="-1"></a><span class="kw">function</span> <span class="fu">App</span>() {</span>
<span id="cb64-27"><a href="#cb64-27" tabindex="-1"></a>  <span class="cf">return </span><span class="fu">&lt;RouterProvider</span> <span class="ot">router</span><span class="op">=</span><span class="va">{</span>router<span class="va">}</span> <span class="fu">/&gt;</span><span class="op">;</span></span>
<span id="cb64-28"><a href="#cb64-28" tabindex="-1"></a>}</span>
<span id="cb64-29"><a href="#cb64-29" tabindex="-1"></a></span>
<span id="cb64-30"><a href="#cb64-30" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> App<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb65"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a><span class="co">// Events.js</span></span>
<span id="cb65-2"><a href="#cb65-2" tabindex="-1"></a><span class="im">import</span> { useLoaderData } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb65-3"><a href="#cb65-3" tabindex="-1"></a></span>
<span id="cb65-4"><a href="#cb65-4" tabindex="-1"></a><span class="im">import</span> EventsList <span class="im">from</span> <span class="st">&#39;../components/EventsList&#39;</span><span class="op">;</span></span>
<span id="cb65-5"><a href="#cb65-5" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" tabindex="-1"></a><span class="kw">function</span> <span class="fu">EventsPage</span>() {</span>
<span id="cb65-7"><a href="#cb65-7" tabindex="-1"></a>  <span class="kw">const</span> events <span class="op">=</span> <span class="fu">useLoaderData</span>()<span class="op">;</span></span>
<span id="cb65-8"><a href="#cb65-8" tabindex="-1"></a></span>
<span id="cb65-9"><a href="#cb65-9" tabindex="-1"></a>  <span class="cf">return </span><span class="fu">&lt;EventsList</span> <span class="ot">events</span><span class="op">=</span><span class="va">{</span>events<span class="va">}</span> <span class="fu">/&gt;</span><span class="op">;</span></span>
<span id="cb65-10"><a href="#cb65-10" tabindex="-1"></a>}</span>
<span id="cb65-11"><a href="#cb65-11" tabindex="-1"></a></span>
<span id="cb65-12"><a href="#cb65-12" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> EventsPage<span class="op">;</span></span>
<span id="cb65-13"><a href="#cb65-13" tabindex="-1"></a></span>
<span id="cb65-14"><a href="#cb65-14" tabindex="-1"></a><span class="im">export</span> <span class="kw">async</span> <span class="kw">function</span> <span class="fu">loader</span>() {</span>
<span id="cb65-15"><a href="#cb65-15" tabindex="-1"></a>  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="st">&#39;http://localhost:8080/events&#39;</span>)<span class="op">;</span></span>
<span id="cb65-16"><a href="#cb65-16" tabindex="-1"></a></span>
<span id="cb65-17"><a href="#cb65-17" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>response<span class="op">.</span><span class="at">ok</span>) {</span>
<span id="cb65-18"><a href="#cb65-18" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb65-19"><a href="#cb65-19" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb65-20"><a href="#cb65-20" tabindex="-1"></a>    <span class="kw">const</span> resData <span class="op">=</span> <span class="cf">await</span> response<span class="op">.</span><span class="fu">json</span>()<span class="op">;</span></span>
<span id="cb65-21"><a href="#cb65-21" tabindex="-1"></a>    <span class="cf">return</span> resData<span class="op">.</span><span class="at">events</span><span class="op">;</span></span>
<span id="cb65-22"><a href="#cb65-22" tabindex="-1"></a>  }</span>
<span id="cb65-23"><a href="#cb65-23" tabindex="-1"></a>}</span></code></pre></div>
<p>A loader függvényben magát a <code>Response</code> objektumot is
adhatjuk, amelyből a <code>useLoaderData</code> hook kinyeri az
adatokat. A <code>fetch</code> eredményeként kapott Promise végül
automatikusan ilyen Response objektumot eredményez, de manuálisan is
létrehozható a <code>new Response(data, configObj)</code>
konstruktorral.</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="kw">function</span> <span class="fu">EventsPage</span>() {</span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>  <span class="co">// Changed here</span></span>
<span id="cb66-3"><a href="#cb66-3" tabindex="-1"></a>  <span class="kw">const</span> data <span class="op">=</span> <span class="fu">useLoaderData</span>()<span class="op">;</span></span>
<span id="cb66-4"><a href="#cb66-4" tabindex="-1"></a>  <span class="kw">const</span> events <span class="op">=</span> data<span class="op">.</span><span class="at">events</span><span class="op">;</span></span>
<span id="cb66-5"><a href="#cb66-5" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" tabindex="-1"></a>  <span class="cf">return </span><span class="fu">&lt;EventsList</span> <span class="ot">events</span><span class="op">=</span><span class="va">{</span>events<span class="va">}</span> <span class="fu">/&gt;</span><span class="op">;</span></span>
<span id="cb66-7"><a href="#cb66-7" tabindex="-1"></a>}</span>
<span id="cb66-8"><a href="#cb66-8" tabindex="-1"></a></span>
<span id="cb66-9"><a href="#cb66-9" tabindex="-1"></a><span class="im">export</span> <span class="kw">async</span> <span class="kw">function</span> <span class="fu">loader</span>() {</span>
<span id="cb66-10"><a href="#cb66-10" tabindex="-1"></a>  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="st">&#39;http://localhost:8080/events&#39;</span>)<span class="op">;</span></span>
<span id="cb66-11"><a href="#cb66-11" tabindex="-1"></a></span>
<span id="cb66-12"><a href="#cb66-12" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>response<span class="op">.</span><span class="at">ok</span>) {</span>
<span id="cb66-13"><a href="#cb66-13" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb66-14"><a href="#cb66-14" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb66-15"><a href="#cb66-15" tabindex="-1"></a>    </span>
<span id="cb66-16"><a href="#cb66-16" tabindex="-1"></a>    <span class="co">// Changed here</span></span>
<span id="cb66-17"><a href="#cb66-17" tabindex="-1"></a>    <span class="cf">return</span> response<span class="op">;</span></span>
<span id="cb66-18"><a href="#cb66-18" tabindex="-1"></a>  }</span>
<span id="cb66-19"><a href="#cb66-19" tabindex="-1"></a>}</span></code></pre></div>
<div id="dinamikus-oldalak" class="section level4">
<h4>Dinamikus oldalak</h4>
<p>A loader függvény a böngészőben fut, ezért használható benne minden
funkció, amire a JS a böngészőben képes, viszont mivel nem komponensről
van szó, ezért pl. React hookokat nem használhatunk benne, így például a
useParams hookot sem. A függvény viszont automatikusan kap egy
objektumot paraméterként, amelyen elérhetők a <code>request</code> és
<code>params</code> property-k. A <code>params</code> property-n pedig,
ahogy a useParams által adott objektumon is, a megfelelő nevekkel
elérhetők az url dinamikus szegmensei.</p>
</div>
</div>
<div id="akciók" class="section level3">
<h3>Akciók</h3>
<p>Az oldalainkhoz akció függvényeket is hozzáadhatunk. Ilyet
használhatunk például az űrlapok elküldéséhez a backendnek. Ezek a
függvények is megkapják a <code>request</code> és <code>params</code>
property-vel rendelkező objektumot paraméterként. Ezekben is minden
olyan kódot használhatunk, amit a böngésző kezelni tud. Hookokat viszont
itt sem használhatunk, hiszen nem komponensekről van szó: így például a
programatikus navigáláshoz a redirect függvényt használjuk a useNavigate
hook helyett.</p>
<p>Az akciót elindítja egy form elküldése az adott útvonalon, vagy
programatikusan is aktiválhatjuk az <code>onSubmit</code> hook révén
kapott <code>submit</code> függvénnyel, amelynek paraméterként egy
objektumot adunk, amelyen beállíthatjuk a <code>method</code> (pl.
<code>post</code>, <code>delete</code>, stb.) és szükség esetén az
<code>action</code> property-ket (ha nem az adott route akcióját akarjuk
élesíteni).</p>
<p>Akárcsak a loaderekek, az actionöknek is lehet return értéke, amelyet
felhasználhatunk a komponensben és ennek megfelelően renderelhetünk
különböző üzeneteket, komponenseket (pl. hibaüzeneteket). Ezekhez a
<code>useActionData</code> hookkal férünk hozzá.</p>
<div id="form-ok-kezelése" class="section level4">
<h4>Form-ok kezelése</h4>
<p>A React Router Dom a formok kezelését is megkönnyíti: a Form
komponens segítségével. Ez automatikusan leállítja a böngésző
alapértelmezett működését submit esetén: az új http request küldését,
viszont a requestet átadja az akciónak, amelyet alapértelmezett esetben
azon a route komponensen írunk meg, amelyen a formot rendereljük. A Form
komponensen megadjuk a <code>method</code> property-t, amit például
<code>post</code>-ra állíthatunk. Ha egy másik route komponens akcióját
szeretnénk futtatni, a Form komponensnek megadhatjuk az
<code>action</code> property-t, amelynek értéke ez a route lesz.</p>
<p>Az elküldendő adatokat az akció függvénye a <code>request</code>
property-n kapja meg automatikusan, amelyen a <code>.formData()</code>
aszinkron metódust használva tudjuk kinyerni az adatokat. Az adatokon
belül az egyes inputok értékeit a <code>.get()</code> metódussal
érhetjük el.</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a><span class="im">import</span> { json<span class="op">,</span> redirect } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb67-2"><a href="#cb67-2" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" tabindex="-1"></a><span class="im">import</span> EventForm <span class="im">from</span> <span class="st">&#39;../components/EventForm&#39;</span><span class="op">;</span></span>
<span id="cb67-4"><a href="#cb67-4" tabindex="-1"></a></span>
<span id="cb67-5"><a href="#cb67-5" tabindex="-1"></a><span class="kw">const</span> NewEventPage <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb67-6"><a href="#cb67-6" tabindex="-1"></a>  <span class="cf">return </span><span class="fu">&lt;EventForm</span> <span class="fu">/&gt;</span><span class="op">;</span></span>
<span id="cb67-7"><a href="#cb67-7" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb67-8"><a href="#cb67-8" tabindex="-1"></a></span>
<span id="cb67-9"><a href="#cb67-9" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> NewEventPage<span class="op">;</span></span>
<span id="cb67-10"><a href="#cb67-10" tabindex="-1"></a></span>
<span id="cb67-11"><a href="#cb67-11" tabindex="-1"></a><span class="im">export</span> <span class="kw">async</span> <span class="kw">function</span> <span class="fu">action</span>({ request }) {</span>
<span id="cb67-12"><a href="#cb67-12" tabindex="-1"></a>  <span class="kw">const</span> data <span class="op">=</span> <span class="cf">await</span> request<span class="op">.</span><span class="fu">formData</span>()<span class="op">;</span></span>
<span id="cb67-13"><a href="#cb67-13" tabindex="-1"></a></span>
<span id="cb67-14"><a href="#cb67-14" tabindex="-1"></a>  <span class="kw">const</span> eventData <span class="op">=</span> {</span>
<span id="cb67-15"><a href="#cb67-15" tabindex="-1"></a>    <span class="dt">title</span><span class="op">:</span> data<span class="op">.</span><span class="fu">get</span>(<span class="st">&#39;title&#39;</span>)<span class="op">,</span></span>
<span id="cb67-16"><a href="#cb67-16" tabindex="-1"></a>    <span class="dt">image</span><span class="op">:</span> data<span class="op">.</span><span class="fu">get</span>(<span class="st">&#39;image&#39;</span>)<span class="op">,</span></span>
<span id="cb67-17"><a href="#cb67-17" tabindex="-1"></a>    <span class="dt">date</span><span class="op">:</span> data<span class="op">.</span><span class="fu">get</span>(<span class="st">&#39;date&#39;</span>)<span class="op">,</span></span>
<span id="cb67-18"><a href="#cb67-18" tabindex="-1"></a>    <span class="dt">description</span><span class="op">:</span> data<span class="op">.</span><span class="fu">get</span>(<span class="st">&#39;description&#39;</span>)<span class="op">,</span></span>
<span id="cb67-19"><a href="#cb67-19" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb67-20"><a href="#cb67-20" tabindex="-1"></a></span>
<span id="cb67-21"><a href="#cb67-21" tabindex="-1"></a>  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="st">&#39;http://localhost:8080/events&#39;</span><span class="op">,</span> {</span>
<span id="cb67-22"><a href="#cb67-22" tabindex="-1"></a>    <span class="dt">method</span><span class="op">:</span> <span class="st">&#39;POST&#39;</span><span class="op">,</span></span>
<span id="cb67-23"><a href="#cb67-23" tabindex="-1"></a>    <span class="dt">headers</span><span class="op">:</span> {</span>
<span id="cb67-24"><a href="#cb67-24" tabindex="-1"></a>      <span class="st">&#39;Content-Type&#39;</span><span class="op">:</span> <span class="st">&#39;application/json&#39;</span><span class="op">,</span></span>
<span id="cb67-25"><a href="#cb67-25" tabindex="-1"></a>    }<span class="op">,</span></span>
<span id="cb67-26"><a href="#cb67-26" tabindex="-1"></a>    <span class="dt">body</span><span class="op">:</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(eventData)<span class="op">,</span></span>
<span id="cb67-27"><a href="#cb67-27" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb67-28"><a href="#cb67-28" tabindex="-1"></a></span>
<span id="cb67-29"><a href="#cb67-29" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>response<span class="op">.</span><span class="at">ok</span>) {</span>
<span id="cb67-30"><a href="#cb67-30" tabindex="-1"></a>    <span class="cf">throw</span> <span class="fu">json</span>({ <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Could not save event&#39;</span> }<span class="op">,</span> { <span class="dt">status</span><span class="op">:</span> <span class="dv">500</span> })<span class="op">;</span></span>
<span id="cb67-31"><a href="#cb67-31" tabindex="-1"></a>  }</span>
<span id="cb67-32"><a href="#cb67-32" tabindex="-1"></a></span>
<span id="cb67-33"><a href="#cb67-33" tabindex="-1"></a>  <span class="cf">return</span> <span class="fu">redirect</span>(<span class="st">&#39;/events&#39;</span>)<span class="op">;</span></span>
<span id="cb67-34"><a href="#cb67-34" tabindex="-1"></a>}</span></code></pre></div>
</div>
</div>
<div id="navigációtól-függő-renderelés" class="section level3">
<h3>Navigációtól függő renderelés</h3>
<p>Amíg nem futott le a loader vagy action függvény, és nem állnak
rendelkezésre a lekért adatok, az új “oldal” vagy az az oldal, ahová
átirányítottunk, nem nyílik meg. A React Router a
<code>useNavigation</code> hookot kínálja, amellyel felhasználhatjuk azt
az információt, hogy éppen folyamatban van-e a navigáció. Ennek return
értéke egy navigáció objektum, amelynek <code>state</code> property-je
három string értéket vehet fel: <code>idle</code>, <code>loading</code>
és <code>submitting</code>. Ennek függvényében renderelhetők különböző
UI komponensek, pl. egy loading spinner vagy valamilyen üzenet.</p>
<p>Így például, amíg a form adatait elküldi a backendnek (POST, PUT,
PATCH vagy DELETE requestek esetén), és megkapja a választ, a
<code>state</code> értéke <code>submitting</code> lesz. Az oldal, amíg
nem kapja meg a loader adatait <code>loading</code> state-et kap. Ha
ezek lefutottak, és nincs aktív navigációs esemény, az <code>idle</code>
értéket veszi fel.</p>
<p>Emellett ezen az objektumon is hozzáférünk a küldött
<code>formData</code>-hoz, illetve a <code>location</code>-höz, amely a
következő helyet adja meg, ahová navigálunk.</p>
</div>
<div id="részek-késleltetett-renderelése" class="section level3">
<h3>Részek késleltetett renderelése</h3>
<p>Néha az oldalak bizonyos részeit késleltetve szeretnénk
megjeleníteni, miközben az oldal többi része már renderelődik. Pl.
időigényesebb fetch művelet befejezése előtt szeretnénk már renderelni a
menüt, illetve azokat a részeket, amelyek nem függnek a fetch-től. Ehhez
a loader függvényben a <code>defer</code> függvényt használhatjuk, a
komponensben pedig a <code>Suspense</code> és <code>Await</code>
komponenseket.</p>
<p>A <code>defer</code>-ben több folyamat eredményére is várhatunk. A
kulcsokat mi adjuk meg tetszés szerint, értékük Promise lehet. Ezért itt
pl. az adatokat betöltő függvényt hívjuk, és ezt adjuk az
<code>events</code> kulcsnak. Mindegyik renderelést külön Suspense és
Await komponenseken belül végezzük.</p>
<p>Ha viszont nem mindegyik betöltést szeretnénk késleltetni, és
egyeseket szeretnénk megvárni az oldal renderelése előtt, megtehetjük,
hogy a defer egyes kulcsainak értéke nem Promise lesz, hanem bevárjuk az
eredményt. Ehhez az <code>await</code>-et használjuk, és ilyenkor a
loader függvénynek <code>async</code>-nek kell lennie. (ld.
EventDetails.js a Router leckénél)</p>
<p>A <code>Suspense</code> az alap React csomag része, és lehetővé
teszi, hogy amíg a benne renderelt komponensek elkészülnek, egy fallback
komponenst rendereljünk.</p>
<p>Az <code>Await</code> komponensnek megadjuk, hogy milyen néven mentse
a sikeres Promise értékét, majd ebbe csomagolunk egy függvényt, amely
megkapja a defer objektumnak azt a kulcsát, amelyre ennek várakoznia
kell, és ezzel renderelhetjük a megfelelő komponenst, a becsomagolt
függvény automatikusan megkapja az eredményt. A függvény argumentumának
neve nem kell, hogy egyezzen a defer objektum megfelelő kulcsával.</p>
<p>Fontos, hogy ebben az esetben a loader defer-jében hívott függvény
nem adhatja a response egészét, hanem a függvényben meg kell várni és
kiszedni belőle a megfelelő adatokat.</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a><span class="im">import</span> { Suspense } <span class="im">from</span> <span class="st">&#39;react&#39;</span><span class="op">;</span></span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a><span class="im">import</span> { useLoaderData<span class="op">,</span> json<span class="op">,</span> defer<span class="op">,</span> Await } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb68-3"><a href="#cb68-3" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" tabindex="-1"></a><span class="im">import</span> EventsList <span class="im">from</span> <span class="st">&#39;../components/EventsList&#39;</span><span class="op">;</span></span>
<span id="cb68-5"><a href="#cb68-5" tabindex="-1"></a></span>
<span id="cb68-6"><a href="#cb68-6" tabindex="-1"></a><span class="kw">function</span> <span class="fu">EventsPage</span>() {</span>
<span id="cb68-7"><a href="#cb68-7" tabindex="-1"></a>  <span class="kw">const</span> { events } <span class="op">=</span> <span class="fu">useLoaderData</span>()<span class="op">;</span></span>
<span id="cb68-8"><a href="#cb68-8" tabindex="-1"></a></span>
<span id="cb68-9"><a href="#cb68-9" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb68-10"><a href="#cb68-10" tabindex="-1"></a>    <span class="fu">&lt;Suspense</span> <span class="ot">fallback</span><span class="op">=</span><span class="va">{</span><span class="kw">&lt;p</span> <span class="ot">style</span><span class="op">=</span><span class="va">{</span>{ <span class="dt">textAlign</span><span class="op">:</span> <span class="st">&#39;center&#39;</span> }<span class="va">}</span><span class="kw">&gt;</span>Loading...<span class="kw">&lt;/p&gt;</span><span class="va">}</span><span class="fu">&gt;</span></span>
<span id="cb68-11"><a href="#cb68-11" tabindex="-1"></a>      <span class="fu">&lt;Await</span> <span class="ot">resolve</span><span class="op">=</span><span class="va">{</span>events<span class="va">}</span><span class="fu">&gt;</span></span>
<span id="cb68-12"><a href="#cb68-12" tabindex="-1"></a>        <span class="va">{</span>(events) <span class="kw">=&gt; </span><span class="fu">&lt;EventsList</span> <span class="ot">events</span><span class="op">=</span><span class="va">{</span>events<span class="va">}</span> <span class="fu">/&gt;</span><span class="va">}</span></span>
<span id="cb68-13"><a href="#cb68-13" tabindex="-1"></a>      <span class="fu">&lt;/Await&gt;</span></span>
<span id="cb68-14"><a href="#cb68-14" tabindex="-1"></a>    <span class="fu">&lt;/Suspense&gt;</span></span>
<span id="cb68-15"><a href="#cb68-15" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb68-16"><a href="#cb68-16" tabindex="-1"></a>}</span>
<span id="cb68-17"><a href="#cb68-17" tabindex="-1"></a></span>
<span id="cb68-18"><a href="#cb68-18" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> EventsPage<span class="op">;</span></span>
<span id="cb68-19"><a href="#cb68-19" tabindex="-1"></a></span>
<span id="cb68-20"><a href="#cb68-20" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">loadEvents</span>() {</span>
<span id="cb68-21"><a href="#cb68-21" tabindex="-1"></a>  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="st">&#39;http://localhost:8080/events&#39;</span>)<span class="op">;</span></span>
<span id="cb68-22"><a href="#cb68-22" tabindex="-1"></a></span>
<span id="cb68-23"><a href="#cb68-23" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>response<span class="op">.</span><span class="at">ok</span>) {</span>
<span id="cb68-24"><a href="#cb68-24" tabindex="-1"></a>    <span class="cf">throw</span> <span class="fu">json</span>(</span>
<span id="cb68-25"><a href="#cb68-25" tabindex="-1"></a>      { <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Could not fetch events.&#39;</span> }<span class="op">,</span></span>
<span id="cb68-26"><a href="#cb68-26" tabindex="-1"></a>      {</span>
<span id="cb68-27"><a href="#cb68-27" tabindex="-1"></a>        <span class="dt">status</span><span class="op">:</span> <span class="dv">500</span><span class="op">,</span></span>
<span id="cb68-28"><a href="#cb68-28" tabindex="-1"></a>      }</span>
<span id="cb68-29"><a href="#cb68-29" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb68-30"><a href="#cb68-30" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb68-31"><a href="#cb68-31" tabindex="-1"></a>    <span class="kw">const</span> resData <span class="op">=</span> <span class="cf">await</span> response<span class="op">.</span><span class="fu">json</span>()<span class="op">;</span></span>
<span id="cb68-32"><a href="#cb68-32" tabindex="-1"></a>    <span class="cf">return</span> resData<span class="op">.</span><span class="at">events</span><span class="op">;</span></span>
<span id="cb68-33"><a href="#cb68-33" tabindex="-1"></a>  }</span>
<span id="cb68-34"><a href="#cb68-34" tabindex="-1"></a>}</span>
<span id="cb68-35"><a href="#cb68-35" tabindex="-1"></a></span>
<span id="cb68-36"><a href="#cb68-36" tabindex="-1"></a><span class="im">export</span> <span class="kw">function</span> <span class="fu">loader</span>() {</span>
<span id="cb68-37"><a href="#cb68-37" tabindex="-1"></a>  <span class="cf">return</span> <span class="fu">defer</span>({</span>
<span id="cb68-38"><a href="#cb68-38" tabindex="-1"></a>    <span class="dt">events</span><span class="op">:</span> <span class="fu">loadEvents</span>()<span class="op">,</span></span>
<span id="cb68-39"><a href="#cb68-39" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb68-40"><a href="#cb68-40" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="usefetcher-loader-vagy-action-élesítése-navigálás-nélkül"
class="section level3">
<h3>useFetcher: loader vagy action élesítése navigálás nélkül</h3>
<p>Ha egy oldal action vagy loader függvényét az oda való navigálás
nélkül szeretnénk használni (pl. hírlevél feliratkozás más oldalakon is,
vagy a navigációban), ezt a <code>useFetcher</code> hookkal tudjuk
megtenni, amely egy olyan fetcher objektumot ad, amelyen számos hasznos
metódus és property érhető el.</p>
<p>Ilyen a <code>fetcher.Form</code>, amely ellentétben a React Router
<code>Form</code> komponensével nem navigál az action oldalra submit
esetén. Az <code>action</code> proppal megadjuk neki, melyik útvonal
actionjét szeretnénk élesíteni, de a navigáció nem történik meg,
maradunk az eredeti oldalon.</p>
<p>A fetcheren is hozzáférünk a folyamat státuszához
(<code>state</code>), a küldött vagy fogadott adatokhoz
(<code>data</code>), a Formmal küldött adatokhoz
(<code>formData</code>)</p>
</div>
<div id="error-handling" class="section level3">
<h3>Error handling</h3>
<p>A loaderekben és akticókban belefuthatunk hibákba, pl. ha a fetch
sikertelen vagy ha az elküldött adatok nem mentek át a validáción. Ilyen
esetekben megtehetjük, hogy más objektumot ad a függvény, amelyet
felhasználunk feltételes rendereléshez, hogy valamilyen hibaüzenetet
jelenítsünk meg. Ahogy fentebb írtam, magát a <code>response</code>-t is
visszaadhatjuk.</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb69-1"><a href="#cb69-1" tabindex="-1"></a><span class="kw">function</span> <span class="fu">EventsPage</span>() {</span>
<span id="cb69-2"><a href="#cb69-2" tabindex="-1"></a>  <span class="kw">const</span> data <span class="op">=</span> <span class="fu">useLoaderData</span>()<span class="op">;</span></span>
<span id="cb69-3"><a href="#cb69-3" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" tabindex="-1"></a>  <span class="cf">if</span> (data<span class="op">.</span><span class="at">isError</span>) {</span>
<span id="cb69-5"><a href="#cb69-5" tabindex="-1"></a>    <span class="cf">return </span><span class="kw">&lt;p&gt;</span><span class="va">{</span>data<span class="op">.</span><span class="at">message</span><span class="va">}</span><span class="kw">&lt;/p&gt;</span><span class="op">;</span></span>
<span id="cb69-6"><a href="#cb69-6" tabindex="-1"></a>  }</span>
<span id="cb69-7"><a href="#cb69-7" tabindex="-1"></a></span>
<span id="cb69-8"><a href="#cb69-8" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb69-9"><a href="#cb69-9" tabindex="-1"></a>}</span>
<span id="cb69-10"><a href="#cb69-10" tabindex="-1"></a></span>
<span id="cb69-11"><a href="#cb69-11" tabindex="-1"></a><span class="im">export</span> <span class="kw">async</span> <span class="kw">function</span> <span class="fu">loader</span>() {</span>
<span id="cb69-12"><a href="#cb69-12" tabindex="-1"></a>  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="st">&#39;http://localhost:8080/events&#39;</span>)<span class="op">;</span></span>
<span id="cb69-13"><a href="#cb69-13" tabindex="-1"></a></span>
<span id="cb69-14"><a href="#cb69-14" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>response<span class="op">.</span><span class="at">ok</span>) {</span>
<span id="cb69-15"><a href="#cb69-15" tabindex="-1"></a>    <span class="cf">return</span> { <span class="dt">isError</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span> <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Could not fetch data&#39;</span> }<span class="op">;</span></span>
<span id="cb69-16"><a href="#cb69-16" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb69-17"><a href="#cb69-17" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb69-18"><a href="#cb69-18" tabindex="-1"></a>  }</span>
<span id="cb69-19"><a href="#cb69-19" tabindex="-1"></a>}</span></code></pre></div>
<p>Másik lehetőség, hogy egy Errort dobunk, aminek hatására a React
Router a legközelebbi <code>errorElement</code>-et használja. Ez lehet
az adott route vagy valamelyik szülő route errorElementje is, ha az a
legközelebbi. De létrehozhatunk új Response objektumot is, és ezt is
dobhatjuk hibaként. Az errorElementként renderelt oldalon is
hozzáférhetünk a Response objektum adataihoz. Ehhez a
<code>useRouteError</code> hookot kínálja a React Router csomag. Ha a
dobott errort a Response konstruktorral hoztuk létre, akkor a kapott
error objektumon lesz egy status property. Ha sima JavaScript
objektumként hoztuk létre a hibát, akkor a hook ezt az objektumot adja
vissza.</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="im">export</span> <span class="kw">async</span> <span class="kw">function</span> <span class="fu">loader</span>() {</span>
<span id="cb70-2"><a href="#cb70-2" tabindex="-1"></a>  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="st">&#39;http://localhost:8080/events&#39;</span>)<span class="op">;</span></span>
<span id="cb70-3"><a href="#cb70-3" tabindex="-1"></a></span>
<span id="cb70-4"><a href="#cb70-4" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>response<span class="op">.</span><span class="at">ok</span>) {</span>
<span id="cb70-5"><a href="#cb70-5" tabindex="-1"></a>    <span class="cf">throw</span> <span class="kw">new</span> <span class="fu">Response</span>(<span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>({ <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Could not fetch events!&#39;</span> })<span class="op">,</span> { <span class="dt">status</span><span class="op">:</span> <span class="dv">500</span> })</span>
<span id="cb70-6"><a href="#cb70-6" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb70-7"><a href="#cb70-7" tabindex="-1"></a>    <span class="cf">return</span> response<span class="op">;</span></span>
<span id="cb70-8"><a href="#cb70-8" tabindex="-1"></a>  }</span>
<span id="cb70-9"><a href="#cb70-9" tabindex="-1"></a>}</span></code></pre></div>
<p>Így létrehozhatunk egy általános hibaoldal komponenst, amelyet a root
szinten rendelünk hozzá, és a tényleges hibától függően más-más
tartalommal töltjük fel.</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb71-1"><a href="#cb71-1" tabindex="-1"></a><span class="im">import</span> { useRouteError } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb71-2"><a href="#cb71-2" tabindex="-1"></a><span class="co">// import ...</span></span>
<span id="cb71-3"><a href="#cb71-3" tabindex="-1"></a></span>
<span id="cb71-4"><a href="#cb71-4" tabindex="-1"></a><span class="kw">const</span> ErrorPage <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb71-5"><a href="#cb71-5" tabindex="-1"></a>  <span class="kw">const</span> error <span class="op">=</span> <span class="fu">useRouteError</span>()<span class="op">;</span></span>
<span id="cb71-6"><a href="#cb71-6" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" tabindex="-1"></a>  <span class="kw">let</span> title <span class="op">=</span> <span class="st">&#39;An error occurred!&#39;</span><span class="op">;</span></span>
<span id="cb71-8"><a href="#cb71-8" tabindex="-1"></a>  <span class="kw">let</span> message <span class="op">=</span> <span class="st">&#39;Something went wrong!&#39;</span><span class="op">;</span></span>
<span id="cb71-9"><a href="#cb71-9" tabindex="-1"></a></span>
<span id="cb71-10"><a href="#cb71-10" tabindex="-1"></a>  <span class="cf">if</span> (error<span class="op">.</span><span class="at">status</span> <span class="op">===</span> <span class="dv">500</span>) {</span>
<span id="cb71-11"><a href="#cb71-11" tabindex="-1"></a>    message <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(error<span class="op">.</span><span class="at">data</span>)<span class="op">.</span><span class="at">message</span><span class="op">;</span></span>
<span id="cb71-12"><a href="#cb71-12" tabindex="-1"></a>  }</span>
<span id="cb71-13"><a href="#cb71-13" tabindex="-1"></a></span>
<span id="cb71-14"><a href="#cb71-14" tabindex="-1"></a>  <span class="cf">if</span> (error<span class="op">.</span><span class="at">status</span> <span class="op">===</span> <span class="dv">404</span>) {</span>
<span id="cb71-15"><a href="#cb71-15" tabindex="-1"></a>    title <span class="op">=</span> <span class="st">&#39;Not found!&#39;</span><span class="op">;</span></span>
<span id="cb71-16"><a href="#cb71-16" tabindex="-1"></a>    message <span class="op">=</span> <span class="st">&#39;Could not find resource or page.&#39;</span><span class="op">;</span></span>
<span id="cb71-17"><a href="#cb71-17" tabindex="-1"></a>  }</span>
<span id="cb71-18"><a href="#cb71-18" tabindex="-1"></a></span>
<span id="cb71-19"><a href="#cb71-19" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb71-20"><a href="#cb71-20" tabindex="-1"></a>    <span class="kw">&lt;&gt;</span></span>
<span id="cb71-21"><a href="#cb71-21" tabindex="-1"></a>      <span class="fu">&lt;MainNavigation</span> <span class="fu">/&gt;</span></span>
<span id="cb71-22"><a href="#cb71-22" tabindex="-1"></a>      <span class="fu">&lt;PageContent</span> <span class="ot">title</span><span class="op">=</span><span class="va">{</span>title<span class="va">}</span><span class="fu">&gt;</span></span>
<span id="cb71-23"><a href="#cb71-23" tabindex="-1"></a>        <span class="kw">&lt;p&gt;</span><span class="va">{</span>message<span class="va">}</span><span class="kw">&lt;/p&gt;</span></span>
<span id="cb71-24"><a href="#cb71-24" tabindex="-1"></a>      <span class="fu">&lt;/PageContent&gt;</span></span>
<span id="cb71-25"><a href="#cb71-25" tabindex="-1"></a>    <span class="kw">&lt;/&gt;</span></span>
<span id="cb71-26"><a href="#cb71-26" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb71-27"><a href="#cb71-27" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p>A Response objektum létrehozásához a React Router csomag a
<code>json</code> utility függvényt is rendelkezésre bocsátja. Ebben az
esetben nincs szükség a JSON.stringify és JSON.parse átalakítások
használatára.</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a><span class="im">import</span> { json } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb72-2"><a href="#cb72-2" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" tabindex="-1"></a><span class="im">export</span> <span class="kw">async</span> <span class="kw">function</span> <span class="fu">loader</span>() {</span>
<span id="cb72-4"><a href="#cb72-4" tabindex="-1"></a>  <span class="kw">const</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="st">&#39;http://localhost:8080/events&#39;</span>)<span class="op">;</span></span>
<span id="cb72-5"><a href="#cb72-5" tabindex="-1"></a></span>
<span id="cb72-6"><a href="#cb72-6" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>response<span class="op">.</span><span class="at">ok</span>) {</span>
<span id="cb72-7"><a href="#cb72-7" tabindex="-1"></a>    <span class="cf">throw</span> <span class="fu">json</span>(</span>
<span id="cb72-8"><a href="#cb72-8" tabindex="-1"></a>      { <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Could not fetch events.&#39;</span> }<span class="op">,</span></span>
<span id="cb72-9"><a href="#cb72-9" tabindex="-1"></a>      {</span>
<span id="cb72-10"><a href="#cb72-10" tabindex="-1"></a>        <span class="dt">status</span><span class="op">:</span> <span class="dv">500</span><span class="op">,</span></span>
<span id="cb72-11"><a href="#cb72-11" tabindex="-1"></a>      }</span>
<span id="cb72-12"><a href="#cb72-12" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb72-13"><a href="#cb72-13" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb72-14"><a href="#cb72-14" tabindex="-1"></a>    <span class="cf">return</span> response<span class="op">;</span></span>
<span id="cb72-15"><a href="#cb72-15" tabindex="-1"></a>  }</span>
<span id="cb72-16"><a href="#cb72-16" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="query-paraméterek" class="section level3">
<h3>Query paraméterek</h3>
<p>Az útvonalakhoz a dinamikus részeken kívül query paramétereket is
adhatunk, amelyek abban különböznek, hogy ezek nem kötelezőek, és
nincsenek hatással az útvonalak illesztésére. Ezekkel viszont
módosíthatjuk azt, mi jelenik meg: pl. növekvő sorrendbe állíthatjuk a
listázást, vagy a loginnál válthatunk a regisztráció és a bejelentkezés
között.</p>
<p>A query paraméterek kinyeréséhez a <code>useSearchParams</code>
hookot használjuk, amely return értéke egy Array: első értéke a kereső
paraméterek, második értéke egy függvény ezek változtatására.</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a><span class="im">import</span> { useSearchParams } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb73-2"><a href="#cb73-2" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" tabindex="-1"></a><span class="kw">function</span> <span class="fu">AuthForm</span>() {</span>
<span id="cb73-4"><a href="#cb73-4" tabindex="-1"></a>  <span class="kw">const</span> [searchParams<span class="op">,</span> setSearchParams] <span class="op">=</span> <span class="fu">useSearchParams</span>()<span class="op">;</span></span>
<span id="cb73-5"><a href="#cb73-5" tabindex="-1"></a>  </span>
<span id="cb73-6"><a href="#cb73-6" tabindex="-1"></a>  <span class="kw">const</span> mode <span class="op">=</span> searchParams<span class="op">.</span><span class="fu">get</span>(<span class="st">&#39;mode&#39;</span>)  <span class="co">// e.g.: www.domain.com/auth?mode=login</span></span>
<span id="cb73-7"><a href="#cb73-7" tabindex="-1"></a>   <span class="co">// ...</span></span>
<span id="cb73-8"><a href="#cb73-8" tabindex="-1"></a>}</span>
<span id="cb73-9"><a href="#cb73-9" tabindex="-1"></a></span>
<span id="cb73-10"><a href="#cb73-10" tabindex="-1"></a><span class="co">//...</span></span></code></pre></div>
<p>Az egyes query paramétereket a <code>.get()</code> metódussal tudjuk
kinyerni.</p>
<p>Az action-ökben és loaderekben a query paraméterekhez úgy férhetünk
hozzá, hogy a <code>request</code> objektumon lévő <code>url</code>
property-t odaadjuk a JavaScript beépített <code>URL</code>
construkctorának, és ezen elérhető lesz a <code>searchParams</code>
property. Ebből szintén a <code>get</code> metódussal nyerhetjük ki a
megfelelő értékeket.</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb74-2"><a href="#cb74-2" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" tabindex="-1"></a><span class="im">export</span> <span class="kw">async</span> <span class="kw">function</span> <span class="fu">action</span>({ request }) {</span>
<span id="cb74-4"><a href="#cb74-4" tabindex="-1"></a>  <span class="kw">const</span> searchParams <span class="op">=</span> <span class="kw">new</span> <span class="fu">URL</span>(request<span class="op">.</span><span class="at">url</span>)<span class="op">.</span><span class="at">searchParams</span><span class="op">;</span></span>
<span id="cb74-5"><a href="#cb74-5" tabindex="-1"></a>  </span>
<span id="cb74-6"><a href="#cb74-6" tabindex="-1"></a>  <span class="kw">const</span> mode <span class="op">=</span> searchParams<span class="op">.</span><span class="fu">get</span>(<span class="st">&#39;mode&#39;</span>) <span class="op">||</span> <span class="st">&#39;login&#39;</span><span class="op">;</span></span>
<span id="cb74-7"><a href="#cb74-7" tabindex="-1"></a>  </span>
<span id="cb74-8"><a href="#cb74-8" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb74-9"><a href="#cb74-9" tabindex="-1"></a>}</span></code></pre></div>
<!-- Az url módosításához ezúttal is a useHistory hookot használhatjuk. A megadott url-be beírjuk a query paramétereket: pl. `/quotes?sort=asc`. Ezekhez egy másik hook segítségével férünk hozzá: a `useLocation` hook return értéke egy location objektum, amelyen elérhető a `search` property, amely tartalmazza a query-t. Ezt a JS beépített URLSearchParams constructor függvényével átalakíthatjuk egy objektummá (pl. queryParams), amelyek key-value párokként fognak szerepelni a query paraméterek: `const queryParams = new URLSearchParams(location.search)` -->
<!-- Az eddigiek egyik hátulütője, hogy ha később módosítani szeretnénk a használt url-eket, sok helyen kell változtatnunk. -->
<!-- A nested route-oknál: -->
<!-- useRouteMatch hook több információt tartalmaz, mint a useLocation: például nem csak a tényleges url-t, hanem az általunk megadott path-t is (pl. `/quotes/:quoteId` és nem csak `/quotes/q2`). Return értéke match objektum. A nested route-oknál használhatjuk a match.path property-t, a nested route-okra mutató linkeknél pedig a match.url property-t, hogy ennek segítségével építsük fel az útvonalakat. -->
<!-- Másik probléma lehet, hogy túl hosszú stringeket kell létrehoznunk. Az útvonalakat objektumokként is megadhatjuk: a pathname értékeként megadhatjuk magát az útvonalat, a search értékeként pedig a query részt stringként. -->
<!-- ### React Router v5 vs. v6: -->
<!-- A `Switch` helyett `Routes` komponenst használhatunk. -->
<!-- A `Route`-okhoz tartozó komponenseket immár nem child komponensként, hanem az `element` proppal adhatjuk meg. Az értéke JSX legyen. Elhagyható az `exact` prop. Ha nem pontos találatokat szeretnénk, az útvonal végére `/*`-ot írhatunk (pl. `/products/*`) -->
<!-- Megváltozott az útvonalak választásának logikája is: Immár nem a megadott sorrendben keres, hanem a lehető legpontosabb találatot keresi. Emiatt nem kell a dinamikus szegmenssel rendelkező route-okat a végére hagyni. -->
<!-- A NavLink-eknél kikerült az activeClassName prop, viszont a className prop speciálisan működik: függvényt is megadhatunk, amely automatikusan megkapja a navData argumentumot, amelyen van egy `.isActive` property boolean, amelyet felhasználhatunk az aktív class hozzáadására: -->
<!-- `<NavLink className={(navData) => navData.isActive ? classes.active : ''}` -->
<!-- Redirect helyett Navigate komponens replace proppal. A replace nélkül is odanavigál, de akkor .push módon, nem pedig .replace módon (vissza lehet lépni). -->
<!-- Beágyazódó útvonalak esetén a Route-okat Routes komponensbe kell ágyazni, akkor is, ha csak egy Route van. Ezen kívül az útvonalak relatívvá váltak, míg korábban abszolút útvonalakat kellett használni. Arra is figyelni kell, hogy a felsőbb szintnél hozzá kell adni a `/*` végződést, hogy ez is élesedjen. -->
<!-- Ugyanígy a Link to propjának megadott útvonalak is relatívvá válnak, ha beágyazódóan vannak megadva, egy másik route-on belül. -->
<!-- A beágyazódó útvonalakat máshogy is megadhatjuk: a fő route definíciós file-ban, ugyanott, ahol megadjuk a fő útvonalat adjuk meg: a megfelelő Route komponens gyermekeként is megadhatjuk a Route komponenst, amely be kell, hogy ágyazódjon. Ezáltal minden útvonal definíció egy helyre kerülhet. Ebben az esetben viszont meg kell adni, hogy a beágyazódó komponenst hol renderelje. Ehhez az Outlet komponenst használjuk. -->
<!-- Arra viszont figyelni kell, hogy minden olyan route élesedik, amely illeszkedik az url-hez, ez pedig azt jelenti, hogy úgy kezdődik, mint a megadott route: tehát pl. `domain.com/products/p1` esetén a `/products/:id` mellett a sima `/products` is. -->
<!-- Ha nem ezt szeretnénk, használhatjuk a Switch komponenst. Ha a Route komponenseket (az összeset egyszerre) ebbe csomagoljuk, csak az a Route fog élesedni, amely az első illeszkedő - fentről lefelé haladva. Ebben az esetben a specifikusabb (pl. id-vel kiegészített) útvonalakat deklaráljuk előbb. Másik megoldás, hogy az exact propot hozzáadjuk a Route komponenshez `<Route path='/products' exact />` -->
<!-- Átirányítás: például, ha a főoldalról át akarunk irányítani: `<Route path="/" exact></Route>` Ezen belül a Redirect komponens használatával átirányíthatunk másik oldalra: `<Redirect to="/welcome" />`. Az exact fontos, hogy ne csináljunk végtelen hurkot. -->
<!-- 404-es hiba oldal: Végül, a switch komponensben, a végén megadhatunk egy útvonalat, amely minden olyan url-re élesedik, amelyet korábban nem kezeltünk: `path="*"`.  -->
<!-- *A korábbi verziókban a `useHistory` hookot lehetett használni, amely egy history objektumot adatt, amelyen a `.push` vagy `.replace` metódussal átirányíthattunk másik oldalra. A különbség, hogy a `.push` után vissza tudunk lépni a böngészőben, a `.replace` után nem.* -->
<!-- Szintén megszűnt a useHistory hook, amely helyett a useNavigate hook használható, amely egy navigate objektumot ad, amely egy függvény, amely paramétere az útvonal. Második paraméterként megadhatunk egy objektomot pl. `replace: true` key-value párral. A navigate függvény számokat is fogadhat: pl. -1 visszalép az előző oldalra, -2 azelé, 1 előre lép. -->
<!-- *Szintén hasznos funkció a Prompt komponens, amely bizonyos feltételek esetén (amelyeket a `when` proppal adhatunk meg) bizonyos üzenetet jelenít meg. Így például, megkérdezhetjük, valóban el akarja-e a felhasználó hagyni az oldalt. A `message` prop értéke egy függvény, amely hozzáférést kap a `location` objektumhoz, amelyből megtudhatjuk például, hogy melyik oldalra navigál a felhasználó. A return érték pedig egy üzenet kell, hogy legyen.* -->
<!-- A Prompt komponens szintén megszűnt, és nem is lett helyettesítve. Ha szükség van rá, hogy megakadályozzuk a navigálást, saját megoldást kell rá találnunk. -->
</div>
</div>
<div id="autentikáció-kezelése" class="section level2">
<h2>Autentikáció kezelése</h2>
</div>
<div id="react-alkalmazások-optimalizálása" class="section level2">
<h2>React alkalmazások optimalizálása</h2>
<hr />
<p>TODO **********************************</p>
<div id="usecallback" class="section level3">
<h3>useCallback</h3>
</div>
<div id="usememo" class="section level3">
<h3>useMemo</h3>
</div>
</div>
<div id="saját-hookok-létrehozása" class="section level2">
<h2>Saját hookok létrehozása</h2>
<hr />
</div>
<div id="stílusok-hozzáadása" class="section level2">
<h2>Stílusok hozzáadása</h2>
<div id="inline-stílusok" class="section level3">
<h3>Inline stílusok</h3>
<p>Reactban is van lehetőség külső css file-t használni, de gyakori az
inline stílusok hozzáadása. A különbség, hogy ez nem simán stringként
történik, hanem JS objektumot kell megadni, amelyben ráadásul a
kebab-case helyett camelCase-t használunk. Mivel JS kód, ezért
<code>{}</code> közé kell tenni, és mivel objektum, ezért még egy pár
<code>{}</code> nyílik rögtön. Az egységek alapértelmezettként px-ben
értendők. Ha nem ezt szeretnénk, akkor stringként kell megadni (pl.
“2rem”, “100%”). Az objektum jöhet egy külön mentett változóból is.</p>
<p>Reactban ez az utóbbi mód a preferált, és így a stílust a state/props
függvényében is meg tudjuk adni: feltételektől függően módosíthatjuk az
objektumot.</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb75-1"><a href="#cb75-1" tabindex="-1"></a><span class="kw">&lt;div</span> <span class="ot">style</span><span class="op">=</span><span class="va">{</span>{<span class="dt">color</span><span class="op">:</span> <span class="st">&quot;yellow&quot;</span><span class="op">,</span> <span class="dt">fontSize</span><span class="op">:</span> <span class="dv">16</span>}<span class="va">}</span><span class="kw">&gt;</span>Mellow Yellow<span class="kw">&lt;/div&gt;</span></span></code></pre></div>
<p>Az inline stílusok használata ugyanakkor nem optimális, mert
kódduplikációhoz vezet: ugyanaz a tulajdonság a CSS file-ban és a js
file-ban is meg van határozva.</p>
</div>
<div id="osztályok-dinamikus-hozzárendelése" class="section level3">
<h3>Osztályok dinamikus hozzárendelése</h3>
<p>Ennél egy fokkal jobb, ha a CsS file-ban megadott osztályokat
dinamikusan rendeljük hozzá, pl. egy template literal segítségével,
amelyben ternary operátorral tesztelhetjük bizonyos feltételek meglétét
vagy rövidre zárást is használhatunk.</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a><span class="kw">&lt;div</span> <span class="ot">classname</span><span class="op">=</span><span class="va">{</span><span class="vs">`form-control </span><span class="sc">${</span><span class="op">!</span>isValid <span class="op">&amp;&amp;</span> <span class="st">&#39;invalid&#39;</span><span class="sc">}</span><span class="vs">`</span><span class="va">}</span></span></code></pre></div>
<p>A sima CSS szabályok ugyanakkor globálisak, nem pedig egy-egy
komponenshez kapcsolódók. Ezt a problémát tudjuk kiküszöbölni a
<code>styled components</code> és a <code>CSS modulok</code>
segítségével.</p>
</div>
<div id="styled-components" class="section level3">
<h3>styled components</h3>
<p>Telepítése: <code>npm i --save styled-components</code></p>
<p>Használata: A komponenst <code>tagged template literal</code>
segítségével hozzuk létre, amelyben minden deklaráció megadható. A
kompiláció során egyedi osztályneveket hoz létre az egyes
komponenseknek, és így a stílusok már ezekhez fognak csak
kapcsolódni.</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a><span class="im">import</span> styled <span class="im">from</span> <span class="st">&#39;styled-components&#39;</span><span class="op">;</span></span>
<span id="cb77-2"><a href="#cb77-2" tabindex="-1"></a></span>
<span id="cb77-3"><a href="#cb77-3" tabindex="-1"></a><span class="kw">const</span> Button <span class="op">=</span> styled<span class="op">.</span><span class="fu">button</span><span class="vs">`</span></span>
<span id="cb77-4"><a href="#cb77-4" tabindex="-1"></a><span class="vs">  background: transparent;</span></span>
<span id="cb77-5"><a href="#cb77-5" tabindex="-1"></a><span class="vs">  border-radius: 3px;</span></span>
<span id="cb77-6"><a href="#cb77-6" tabindex="-1"></a><span class="vs">  border: 2px solid palevioletred;</span></span>
<span id="cb77-7"><a href="#cb77-7" tabindex="-1"></a><span class="vs">  color: palevioletred;</span></span>
<span id="cb77-8"><a href="#cb77-8" tabindex="-1"></a><span class="vs">  margin: 0 1em;</span></span>
<span id="cb77-9"><a href="#cb77-9" tabindex="-1"></a><span class="vs">  padding: 0.25em 1em;</span></span>
<span id="cb77-10"><a href="#cb77-10" tabindex="-1"></a><span class="vs">`</span></span></code></pre></div>
<p>A template literalon belül minden css selector használható, beleértve
a pseudo-selectorokat és media query-ket. Mivel nem használunk
szelektort, ezért a pseudo-selectorok <code>&amp;:hover</code> és
hasonló formákban adhatók meg, ahol a <code>&amp;</code> jelzi a
selector helyét.</p>
<p>Ezen kívül használhatunk más styled componenteket is selectorként az
alábbi módon:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a><span class="kw">const</span> Container <span class="op">=</span> styled<span class="op">.</span><span class="fu">div</span><span class="vs">`</span></span>
<span id="cb78-2"><a href="#cb78-2" tabindex="-1"></a><span class="vs"> // styles declarations</span></span>
<span id="cb78-3"><a href="#cb78-3" tabindex="-1"></a><span class="vs"> </span></span>
<span id="cb78-4"><a href="#cb78-4" tabindex="-1"></a><span class="vs"> </span><span class="sc">${</span>Button<span class="sc">}</span><span class="vs"> {</span></span>
<span id="cb78-5"><a href="#cb78-5" tabindex="-1"></a><span class="vs">  // Button styles declarations</span></span>
<span id="cb78-6"><a href="#cb78-6" tabindex="-1"></a><span class="vs">}</span></span>
<span id="cb78-7"><a href="#cb78-7" tabindex="-1"></a><span class="vs">`</span></span></code></pre></div>
<p>Saját, illetve beépített komponenseknek is megadhatunk stílust, ha
argumentumként adjuk ezeket a <code>styled()</code> függvénynek:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb79-1"><a href="#cb79-1" tabindex="-1"></a><span class="im">import</span> { Link } <span class="im">from</span> <span class="st">&#39;react-router-dom&#39;</span><span class="op">;</span></span>
<span id="cb79-2"><a href="#cb79-2" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" tabindex="-1"></a><span class="kw">const</span> NavLink <span class="op">=</span> <span class="fu">styled</span>(Link)<span class="vs">`</span></span>
<span id="cb79-4"><a href="#cb79-4" tabindex="-1"></a><span class="vs">  // styles</span></span>
<span id="cb79-5"><a href="#cb79-5" tabindex="-1"></a><span class="vs">`</span><span class="op">;</span></span></code></pre></div>
<p>Ezt felhasználhatjuk arra is, hogy alstílusokat hozzunk létre:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a><span class="kw">const</span> BaseButton <span class="op">=</span> styled<span class="op">.</span><span class="fu">button</span><span class="vs">`</span></span>
<span id="cb80-2"><a href="#cb80-2" tabindex="-1"></a><span class="vs">  // common styling</span></span>
<span id="cb80-3"><a href="#cb80-3" tabindex="-1"></a><span class="vs">`</span></span>
<span id="cb80-4"><a href="#cb80-4" tabindex="-1"></a></span>
<span id="cb80-5"><a href="#cb80-5" tabindex="-1"></a><span class="kw">const</span> InvertedButton <span class="op">=</span> <span class="fu">styled</span>(BaseButton)<span class="vs">`</span></span>
<span id="cb80-6"><a href="#cb80-6" tabindex="-1"></a><span class="vs">  // specific styles</span></span>
<span id="cb80-7"><a href="#cb80-7" tabindex="-1"></a><span class="vs">`</span></span>
<span id="cb80-8"><a href="#cb80-8" tabindex="-1"></a></span>
<span id="cb80-9"><a href="#cb80-9" tabindex="-1"></a><span class="kw">const</span> TransparentButton <span class="op">=</span> <span class="fu">styled</span>(BaseButton)<span class="vs">`</span></span>
<span id="cb80-10"><a href="#cb80-10" tabindex="-1"></a><span class="vs">  // specific styles</span></span>
<span id="cb80-11"><a href="#cb80-11" tabindex="-1"></a><span class="vs">`</span></span></code></pre></div>
<p>Az így létrehozott styled komponenseket egy külön file-ban is
létrehozhatjuk, és exportálhatjuk, és ezek után az importált
komponenseket használhatjuk az alap html tag-ek helyett.</p>
<p>A styled components-ben props-okat is használhatunk: anonim
függvényeket illeszthetünk be JavaScript kifejezésként, amelyek
hozzáférnek a props-hoz (dekonstruálható) és a return értékük lesz
beillesztve a megfelelő helyre:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb81-1"><a href="#cb81-1" tabindex="-1"></a><span class="kw">const</span> BackgroundImage <span class="op">=</span> styled<span class="op">.</span><span class="fu">div</span><span class="vs">`</span></span>
<span id="cb81-2"><a href="#cb81-2" tabindex="-1"></a><span class="vs">  // styles</span></span>
<span id="cb81-3"><a href="#cb81-3" tabindex="-1"></a><span class="vs">  background-image: </span><span class="sc">${</span>(props) <span class="kw">=&gt;</span> <span class="vs">`url(</span><span class="sc">${</span>props<span class="op">.</span><span class="at">imageUrl</span><span class="sc">}</span><span class="vs">)`</span><span class="sc">}</span><span class="vs">;</span></span>
<span id="cb81-4"><a href="#cb81-4" tabindex="-1"></a><span class="vs">`</span></span></code></pre></div>
<p>Ezeket aztán ahol használjuk a komponenst, megadhatjuk, ahogy a
props-okat amúgy is szoktuk. A speciális osztályokat is így adjuk meg,
ha styled komponenseket használunk: ebben az esetben boolean értékként,
és a stílusok deklarációjánál ezeket felhasználhatjuk pl. egy ternary
operátorban vagy rövidre zárásban.</p>
<p>A styled componentekhez <code>css</code> blokkokat is használhatunk,
például a Sass <code>mixin</code>-jeinek kiváltására. A css változókat
sima JS változókkal helyettesíthetjük, amelyek string értéket
kapnak.</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a><span class="im">import</span> styled<span class="op">,</span> { css } <span class="im">from</span> <span class="st">&#39;styled-components&#39;</span><span class="op">;</span></span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a><span class="kw">const</span> subColor <span class="op">=</span> <span class="st">&#39;grey&#39;</span><span class="op">;</span></span>
<span id="cb82-4"><a href="#cb82-4" tabindex="-1"></a><span class="kw">const</span> mainColor <span class="op">=</span> <span class="st">&#39;black&#39;</span><span class="op">;</span></span>
<span id="cb82-5"><a href="#cb82-5" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" tabindex="-1"></a><span class="kw">const</span> shrinkLabelStyles <span class="op">=</span> <span class="fu">css</span><span class="vs">`</span></span>
<span id="cb82-7"><a href="#cb82-7" tabindex="-1"></a><span class="vs">  top: -14px;</span></span>
<span id="cb82-8"><a href="#cb82-8" tabindex="-1"></a><span class="vs">  font-size: 12px;</span></span>
<span id="cb82-9"><a href="#cb82-9" tabindex="-1"></a><span class="vs">  color: </span><span class="sc">${</span>mainColor<span class="sc">}</span><span class="vs">;</span></span>
<span id="cb82-10"><a href="#cb82-10" tabindex="-1"></a><span class="vs">`</span><span class="op">;</span></span>
<span id="cb82-11"><a href="#cb82-11" tabindex="-1"></a></span>
<span id="cb82-12"><a href="#cb82-12" tabindex="-1"></a><span class="im">export</span> <span class="kw">const</span> FormInputLabel <span class="op">=</span> styled<span class="op">.</span><span class="fu">label</span><span class="vs">`</span></span>
<span id="cb82-13"><a href="#cb82-13" tabindex="-1"></a><span class="vs">  color: </span><span class="sc">${</span>subColor<span class="sc">}</span><span class="vs">;</span></span>
<span id="cb82-14"><a href="#cb82-14" tabindex="-1"></a><span class="vs">  // more style declarations</span></span>
<span id="cb82-15"><a href="#cb82-15" tabindex="-1"></a></span>
<span id="cb82-16"><a href="#cb82-16" tabindex="-1"></a><span class="vs">  // apply css based on prop truthyness</span></span>
<span id="cb82-17"><a href="#cb82-17" tabindex="-1"></a><span class="vs">  </span><span class="sc">${</span>({ shrink }) <span class="kw">=&gt;</span> shrink <span class="op">&amp;&amp;</span> shrinkLabelStyles<span class="sc">}</span></span>
<span id="cb82-18"><a href="#cb82-18" tabindex="-1"></a><span class="vs">`</span><span class="op">;</span></span>
<span id="cb82-19"><a href="#cb82-19" tabindex="-1"></a></span>
<span id="cb82-20"><a href="#cb82-20" tabindex="-1"></a><span class="im">export</span> <span class="kw">const</span> Input <span class="op">=</span> styled<span class="op">.</span><span class="fu">input</span><span class="vs">`</span></span>
<span id="cb82-21"><a href="#cb82-21" tabindex="-1"></a><span class="vs">  // style declarations</span></span>
<span id="cb82-22"><a href="#cb82-22" tabindex="-1"></a></span>
<span id="cb82-23"><a href="#cb82-23" tabindex="-1"></a><span class="vs">  // if input focused target sibling FormInputLabel and apply css block</span></span>
<span id="cb82-24"><a href="#cb82-24" tabindex="-1"></a><span class="vs">  &amp;:focus ~ </span><span class="sc">${</span>FormInputLabel<span class="sc">}</span><span class="vs"> {</span></span>
<span id="cb82-25"><a href="#cb82-25" tabindex="-1"></a><span class="vs">    </span><span class="sc">${</span>shrinkLabelStyles<span class="sc">}</span></span>
<span id="cb82-26"><a href="#cb82-26" tabindex="-1"></a><span class="vs">  }</span></span>
<span id="cb82-27"><a href="#cb82-27" tabindex="-1"></a><span class="vs">`</span><span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb83"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb83-1"><a href="#cb83-1" tabindex="-1"></a><span class="im">import</span> { FormInputLabel<span class="op">,</span> Input<span class="op">,</span> Group } <span class="im">from</span> <span class="st">&#39;./form-input.styles&#39;</span><span class="op">;</span></span>
<span id="cb83-2"><a href="#cb83-2" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" tabindex="-1"></a><span class="kw">const</span> FormInput <span class="op">=</span> ({ label<span class="op">,</span> <span class="op">...</span>otherProps }) <span class="kw">=&gt;</span> {</span>
<span id="cb83-4"><a href="#cb83-4" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb83-5"><a href="#cb83-5" tabindex="-1"></a>    <span class="fu">&lt;Group&gt;</span></span>
<span id="cb83-6"><a href="#cb83-6" tabindex="-1"></a>      <span class="fu">&lt;Input</span> <span class="va">{</span><span class="op">...</span>otherProps<span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb83-7"><a href="#cb83-7" tabindex="-1"></a>      <span class="va">{</span>label <span class="op">&amp;&amp;</span> (</span>
<span id="cb83-8"><a href="#cb83-8" tabindex="-1"></a>        <span class="fu">&lt;FormInputLabel</span> <span class="ot">shrink</span><span class="op">=</span><span class="va">{</span>otherProps<span class="op">.</span><span class="at">value</span><span class="op">.</span><span class="at">length</span><span class="va">}</span><span class="fu">&gt;</span></span>
<span id="cb83-9"><a href="#cb83-9" tabindex="-1"></a>          <span class="va">{</span>label<span class="va">}</span></span>
<span id="cb83-10"><a href="#cb83-10" tabindex="-1"></a>        <span class="fu">&lt;/FormInputLabel&gt;</span></span>
<span id="cb83-11"><a href="#cb83-11" tabindex="-1"></a>      )<span class="va">}</span></span>
<span id="cb83-12"><a href="#cb83-12" tabindex="-1"></a>    <span class="fu">&lt;/Group&gt;</span></span>
<span id="cb83-13"><a href="#cb83-13" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb83-14"><a href="#cb83-14" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb83-15"><a href="#cb83-15" tabindex="-1"></a></span>
<span id="cb83-16"><a href="#cb83-16" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> FormInput<span class="op">;</span></span></code></pre></div>
</div>
<div id="css-modulok" class="section level3">
<h3>CSS modulok</h3>
<p>Jól használható mód a css modul megközelítés. A css stílusokat
importáljuk a <code>.module.css</code> kiterjesztésű file-okból, ami
eredményeképpen egy objektumot kapunk, amelyen a különböző osztályok
property-ként jönnek létre. Ezeket aztán hozzáadhatjuk a JSX-ben a
<code>className</code> attribútum segítségével az alábbi formában.</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a><span class="im">import</span> classes <span class="im">from</span> <span class="st">&#39;./Item.module.css&#39;</span><span class="op">;</span></span>
<span id="cb84-2"><a href="#cb84-2" tabindex="-1"></a></span>
<span id="cb84-3"><a href="#cb84-3" tabindex="-1"></a><span class="kw">const</span> Item <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb84-4"><a href="#cb84-4" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb84-5"><a href="#cb84-5" tabindex="-1"></a>    <span class="kw">&lt;div</span> <span class="ot">className</span><span class="op">=</span><span class="va">{</span>classes<span class="op">.</span><span class="at">container</span><span class="va">}</span><span class="kw">&gt;</span></span>
<span id="cb84-6"><a href="#cb84-6" tabindex="-1"></a>      <span class="kw">&lt;div</span> <span class="ot">className</span><span class="op">=</span><span class="va">{</span>classes[<span class="st">&#39;content-long&#39;</span>]<span class="va">}</span><span class="kw">&gt;</span></span>
<span id="cb84-7"><a href="#cb84-7" tabindex="-1"></a>        <span class="va">{</span><span class="co">/* Ide jön a tartalom */</span><span class="va">}</span></span>
<span id="cb84-8"><a href="#cb84-8" tabindex="-1"></a>      <span class="kw">&lt;/div&gt;</span></span>
<span id="cb84-9"><a href="#cb84-9" tabindex="-1"></a>    <span class="kw">&lt;/div&gt;</span></span>
<span id="cb84-10"><a href="#cb84-10" tabindex="-1"></a>  )</span>
<span id="cb84-11"><a href="#cb84-11" tabindex="-1"></a>}</span></code></pre></div>
<p>Minden komponenshez külön css module file-t hozunk létre, és
importáljuk a komponens file-jában. Nem jelent problémát, ha ismétlődnek
a class nevek, mivel a háttérben egyedi class-nevek jönnek létre a
megadottakból.</p>
<p>Ez a megoldás ötvözi az önálló css file-ok előnyét a stílusoknak a
komponensekhez való kötésével, amit a styled components is hoz. Akárcsak
a sima class-nevek, feltételesen is hozzáadhatók (ld. fent).</p>
<p>A media query-k egyszerűen létrehozhatók a szokásos módon a css
file-okban.</p>
</div>
<div id="icons-images-svg" class="section level3">
<h3>Icons, images &amp; svg</h3>
<div class="sourceCode" id="cb85"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb85-1"><a href="#cb85-1" tabindex="-1"></a><span class="im">import</span> { ReactComponent <span class="im">as</span> ShoppingSvg } <span class="im">from</span> <span class="st">&#39;../../assets/shopping-bag.svg&#39;</span><span class="op">;</span></span>
<span id="cb85-2"><a href="#cb85-2" tabindex="-1"></a></span>
<span id="cb85-3"><a href="#cb85-3" tabindex="-1"></a><span class="co">// After: npm i react-icons</span></span>
<span id="cb85-4"><a href="#cb85-4" tabindex="-1"></a><span class="im">import</span> <span class="op">...</span> <span class="im">from</span> <span class="st">&#39;react-icons/fa&#39;</span>  </span></code></pre></div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
